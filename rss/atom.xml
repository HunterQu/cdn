<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hunter&#39;s Blog</title>
  
  
  <link href="https://hntr.xyz/atom.xml" rel="self"/>
  
  <link href="https://hntr.xyz/"/>
  <updated>2020-08-16T06:11:50.106Z</updated>
  <id>https://hntr.xyz/</id>
  
  <author>
    <name>Hunter_H</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>P2709的一枚题解</title>
    <link href="https://hntr.xyz/P2709.html"/>
    <id>https://hntr.xyz/P2709.html</id>
    <published>2020-08-10T16:00:00.000Z</published>
    <updated>2020-08-16T06:11:50.106Z</updated>
    
    <content type="html"><![CDATA[<p>有一个长为$a$, 值域为$[1,k]$的序列</p><p>对于每个询问区间$[l,r]$</p><p>求</p><p>$$<br>\sum^k_{i=1}{c^2_i}<br>$$</p><p>其中$c_i$表示数字$i$在$[l,r]$中出现的次数</p><p>莫队是由前国家队队长莫涛发明的</p><p>莫队算法的精髓就是通过合理地对询问排序，然后以较优的顺序暴力回答每个询问。处理完一个询问后，可以使用它的信息得到下一个询问区间的答案。（两个边界瞎跳）</p><p>考虑这个问题：对于上面这道题，我们知道区间$[1,5]$的答案，就可以求出$[2,6]$每个数的数量</p><p>莫队提供了这样一个排序方案：将原序列以$\sqrt{n}$为一块进行分块（分块的大小也珂以调整），排序第一关键字是询问的左端点所在块的编号，第二关键字是询问的右端点本身的位置，都是升序。然后我们用上面提到的“移动当前区间左右端点”的方法，按顺序求每个询问区间的答案，移动每一个询问区间左右端点可以求出下一个区间的答案。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> pos[a.l] == pos[b.l] ? a.r &lt; b.r : pos[a.l] &lt; pos[b.l];</span><br></pre></td></tr></table></figure><p>这道题目只要分块排序亿下之后</p><a id="more"></a><p>就可以<del>暴力</del>解决了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="keyword">while</span> (q[i].l &lt; l) add(--l);</span><br><span class="line">        <span class="keyword">while</span> (q[i].r &gt; r) add(++r);</span><br><span class="line">        <span class="keyword">while</span> (q[i].l &gt; l) sub(l++);</span><br><span class="line">        <span class="keyword">while</span> (q[i].r &lt; r) sub(r--);</span><br><span class="line">        ans[q[i].k] = res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><del>莫队经典片段</del></p><p>更新代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cnt[a[x]]++; </span><br><span class="line">    res = res - (cnt[a[x]] - <span class="number">1</span>) * (cnt[a[x]] - <span class="number">1</span>) + cnt[a[x]] * cnt[a[x]]; </span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> x)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cnt[a[x]]--; </span><br><span class="line">    res = res - (cnt[a[x]] + <span class="number">1</span>) * (cnt[a[x]] + <span class="number">1</span>) + cnt[a[x]] * cnt[a[x]]; </span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>复杂度大约是 $O(n\sqrt{n})$</p><p>全部代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 50010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[MAXN], cnt[MAXN], pos[MAXN], n, m, k;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans[MAXN], res;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Q</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, k;</span><br><span class="line">&#125;q[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;cnt[a[x]]++; res = res - (cnt[a[x]] - <span class="number">1</span>) * (cnt[a[x]] - <span class="number">1</span>) + cnt[a[x]] * cnt[a[x]]; <span class="keyword">return</span>;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;cnt[a[x]]--; res = res - (cnt[a[x]] + <span class="number">1</span>) * (cnt[a[x]] + <span class="number">1</span>) + cnt[a[x]] * cnt[a[x]]; <span class="keyword">return</span>;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Q a, Q b)</span></span>&#123;<span class="keyword">return</span> pos[a.l] == pos[b.l] ? a.r &lt; b.r : pos[a.l] &lt; pos[b.l];&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        freopen(<span class="string">&quot;in.in&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line">        freopen(<span class="string">&quot;out.out&quot;</span>, <span class="string">&quot;w&quot;</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">    <span class="keyword">int</span> siz = <span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">        pos[i] = i / siz;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;q[i].l, &amp;q[i].r);</span><br><span class="line">        q[i].k = i;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(q + <span class="number">1</span>, q + m + <span class="number">1</span>, cmp);</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">2</span>, r = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="keyword">while</span> (q[i].l &lt; l) add(--l);</span><br><span class="line">        <span class="keyword">while</span> (q[i].r &gt; r) add(++r);</span><br><span class="line">        <span class="keyword">while</span> (q[i].l &gt; l) sub(l++);</span><br><span class="line">        <span class="keyword">while</span> (q[i].r &lt; r) sub(r--);</span><br><span class="line">        ans[q[i].k] = res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;有一个长为$a$, 值域为$[1,k]$的序列&lt;/p&gt;
&lt;p&gt;对于每个询问区间$[l,r]$&lt;/p&gt;
&lt;p&gt;求&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;\sum^k_{i=1}{c^2_i}&lt;br&gt;$$&lt;/p&gt;
&lt;p&gt;其中$c_i$表示数字$i$在$[l,r]$中出现的次数&lt;/p&gt;
&lt;p&gt;莫队是由前国家队队长莫涛发明的&lt;/p&gt;
&lt;p&gt;莫队算法的精髓就是通过合理地对询问排序，然后以较优的顺序暴力回答每个询问。处理完一个询问后，可以使用它的信息得到下一个询问区间的答案。（两个边界瞎跳）&lt;/p&gt;
&lt;p&gt;考虑这个问题：对于上面这道题，我们知道区间$[1,5]$的答案，就可以求出$[2,6]$每个数的数量&lt;/p&gt;
&lt;p&gt;莫队提供了这样一个排序方案：将原序列以$\sqrt{n}$为一块进行分块（分块的大小也珂以调整），排序第一关键字是询问的左端点所在块的编号，第二关键字是询问的右端点本身的位置，都是升序。然后我们用上面提到的“移动当前区间左右端点”的方法，按顺序求每个询问区间的答案，移动每一个询问区间左右端点可以求出下一个区间的答案。&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; pos[a.l] == pos[b.l] ? a.r &amp;lt; b.r : pos[a.l] &amp;lt; pos[b.l];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;这道题目只要分块排序亿下之后&lt;/p&gt;</summary>
    
    
    
    <category term="算法学习" scheme="https://hntr.xyz/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="luogu" scheme="https://hntr.xyz/tags/luogu/"/>
    
    <category term="莫队" scheme="https://hntr.xyz/tags/%E8%8E%AB%E9%98%9F/"/>
    
  </entry>
  
  <entry>
    <title>题目题解-开车旅行</title>
    <link href="https://hntr.xyz/P1081-%E5%80%8D%E5%A2%9E.html"/>
    <id>https://hntr.xyz/P1081-%E5%80%8D%E5%A2%9E.html</id>
    <published>2020-08-09T16:00:00.000Z</published>
    <updated>2020-08-16T06:10:08.355Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1081">P1081</a></p><h3 id="题目简述"><a href="#题目简述" class="headerlink" title="题目简述"></a>题目简述</h3><p>有一排高低不同的城市  <strong>城市距离=高度差</strong></p><p>A和B自左向右开车旅行（出发点可以变）</p><p>A、B的开车风格：</p><blockquote><p>1.A会前往右边距他<strong>第二近</strong>的城市<br>2.B会前往右边<strong>最近</strong>的城市<br>3.A和B开过的<strong>总里程</strong>不超过$X$</p></blockquote><p><strong>询问:</strong></p><p>1.给定一个$X$ 求出从哪个城市出发  $A$的路程/$B$的路程  最大</p><p>2.给定$X_i$和出发城市$S_i$ 求$A$和$B$分别开的距离数</p><h3 id="倍增"><a href="#倍增" class="headerlink" title="倍增"></a>倍增</h3><p>在没有修改的<code>RMQ</code>问题(区间最值问题) 基于<strong>倍增</strong>的ST表可以做到$O(1)$查询和$O(nlogn)$预处理</p><p>拿最大值来说我们用$Max[i][j]$表示，从$i$位置开始的$2^j$个数中的最大值，例如$Max[i][1]$表示的是$i$位置和$i+1$位置中两个数的最大值(也就是说当前位置是被包含进$2^j$个数去的)</p><p>那么转移的时候我们可以把当前区间拆成两个区间并分别取最大值</p><p>比如</p><a id="more"></a><p><img src="https://hntr.xyz/img/st/transfer.jpg" alt="transfer"></p><p>$$<br>f[i][j] = \max{f[i][j - 1], f[i + (1 &lt;&lt; (j - 1))][j - 1]}<br>$$</p><p>上面就是一般倍增用来求最大值时候的转移式(没什么用不用看</p><p>另一个倍增的常见应用就是$LCA$</p><p>通过倍增的思想向上跳</p><h3 id="那么"><a href="#那么" class="headerlink" title="那么"></a>那么</h3><p>这道题目</p><p>我们可以利用倍增向右跳</p><p>但是我们要先处理出$f[i][0]$</p><p>也就是从任意一个城市开始 走一步到达的城市</p><p>首先就要处理出对于到达每一个城市$a_i$   $A$和$B$的下一步会去哪里</p><p>这一步可以用一个双向链表 开始的时候将城市从低到高排序并且相邻的相连</p><p>就像这个</p><p><img src="https://i.loli.net/2020/08/08/4QHkoeWvg1d2JtL.png" alt="image.png"></p><p>排序完之后的顺序是  3 1 2 4</p><p>每一个点都与旁边相连</p><p>之后从原来顺序开始处理 不断选出A和B的选择然后删除这个节点 就可以处理完 <code>na</code>和<code>nb</code>数组</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">left</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!l) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!r) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> d[j].v-d[l].v&lt;=d[r].v-d[j].v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        j = p[i]; l = d[j].l; r = d[j].r;</span><br><span class="line">        <span class="keyword">if</span> (left()) </span><br><span class="line">            nb[i] = d[l].i, na[i] = pd(d[l].l, r);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            nb[i] = d[r].i, na[i] = pd(l, d[r].r);</span><br><span class="line">        <span class="keyword">if</span> (l) d[l].r = r;</span><br><span class="line">        <span class="keyword">if</span> (r) d[r].l = l;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>$na[i]$表示在$i$号城市时，$A$的下一个城市</p><p>之后就可以将A开一天B开一天当作一步</p><p>用倍增来初始化 $f[i][j]$从$i$号城市开始 走$2^j$大步后到达的城市</p><p>$sta[i][j]$表示从$i$号城市开始 走$2^j$大步后 A走过的路程（是一个累计量</p><p>$stb$数组同理</p><p>这样我们就可以用倍增枚举和找到符合要求的答案</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getab</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    a = b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">19</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (f[p][i] &amp;&amp; (<span class="keyword">long</span> <span class="keyword">long</span>)(a + b + stA[p][i]+stB[p][i]) &lt;= x) &#123;</span><br><span class="line">            a += stA[p][i];</span><br><span class="line">            b += stB[p][i];</span><br><span class="line">            p = f[p][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (na[p] &amp;&amp; a + b + stA[p][<span class="number">0</span>] &lt;= x) a += stA[p][<span class="number">0</span>];</span><br><span class="line">    <span class="comment">//因为f表示的是一大步（ab各一步） 所以可能A还可以走一步</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, l, r, j;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> i, v, l, r;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp; A) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> v &lt; A.v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;d[<span class="number">100005</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> h[<span class="number">100005</span>], p[<span class="number">100005</span>];</span><br><span class="line"><span class="keyword">int</span> stA[<span class="number">100005</span>][<span class="number">21</span>], stB[<span class="number">100005</span>][<span class="number">21</span>], f[<span class="number">100005</span>][<span class="number">21</span>];</span><br><span class="line"><span class="keyword">int</span> na[<span class="number">100005</span>], nb[<span class="number">100005</span>], a, b, ans = n;</span><br><span class="line"><span class="keyword">double</span> minn = <span class="number">2147483647</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">left</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!l) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!r) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> d[j].v-d[l].v&lt;=d[r].v-d[j].v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!a) <span class="keyword">return</span> d[b].i;</span><br><span class="line">    <span class="keyword">if</span> (!b) <span class="keyword">return</span> d[a].i;</span><br><span class="line">    <span class="keyword">if</span> (d[j].v-d[a].v &lt;= d[b].v-d[j].v) <span class="keyword">return</span> d[a].i;</span><br><span class="line">    <span class="keyword">return</span> d[b].i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">make_st</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">19</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            f[i][j] = f[f[i][j<span class="number">-1</span>]][j<span class="number">-1</span>];</span><br><span class="line">            <span class="comment">//位置</span></span><br><span class="line">            stA[i][j] = stA[i][j<span class="number">-1</span>] + stA[f[i][j<span class="number">-1</span>]][j<span class="number">-1</span>];</span><br><span class="line">            stB[i][j] = stB[i][j<span class="number">-1</span>] + stB[f[i][j<span class="number">-1</span>]][j<span class="number">-1</span>];</span><br><span class="line">            <span class="comment">//距离</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getab</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    a = b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">19</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (f[p][i] &amp;&amp; (<span class="keyword">long</span> <span class="keyword">long</span>)(a + b + stA[p][i]+stB[p][i]) &lt;= x) &#123;</span><br><span class="line">            a += stA[p][i];</span><br><span class="line">            b += stB[p][i];</span><br><span class="line">            p = f[p][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (na[p] &amp;&amp; a + b + stA[p][<span class="number">0</span>] &lt;= x) a += stA[p][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">&quot;in.in&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">&quot;out.out&quot;</span>, <span class="string">&quot;w&quot;</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> x;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;d[i].v);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">        d[i].i = i;</span><br><span class="line"></span><br><span class="line">    sort(d + <span class="number">1</span>, d + n + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        p[d[i].i] = i;<span class="comment">//记录原本的顺序 p[i]存放了原来在i位置的城市排序完的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        d[i].l = i<span class="number">-1</span>, d[i].r = i+<span class="number">1</span>;</span><br><span class="line">    d[<span class="number">1</span>].l = d[n].r = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        j = p[i]; l = d[j].l; r = d[j].r;</span><br><span class="line">        <span class="keyword">if</span> (left()) </span><br><span class="line">            nb[i] = d[l].i, na[i] = pd(d[l].l, r);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            nb[i] = d[r].i, na[i] = pd(l, d[r].r);</span><br><span class="line">        <span class="keyword">if</span> (l) d[l].r = r;</span><br><span class="line">        <span class="keyword">if</span> (r) d[r].l = l;</span><br><span class="line">    &#125;<span class="comment">//na, nb是对于原来的第i号城市 A和B的下一个目的地</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, na[i]);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, nb[i]);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        f[i][<span class="number">0</span>] = nb[na[i]];</span><br><span class="line">        <span class="comment">//A和B一起倍增</span></span><br><span class="line">        stA[i][<span class="number">0</span>] = <span class="built_in">abs</span>(d[p[i]].v - d[p[na[i]]].v);</span><br><span class="line">        stB[i][<span class="number">0</span>] = <span class="built_in">abs</span>(d[p[na[i]]].v - d[p[f[i][<span class="number">0</span>]]].v);</span><br><span class="line">        <span class="comment">//A和B  在A一步B一部之后 分别移动的的距离</span></span><br><span class="line">    &#125;</span><br><span class="line">    make_st();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%d&quot;</span>, &amp;x, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        getab(x, i);</span><br><span class="line">        <span class="keyword">if</span> (b &amp;&amp; <span class="number">1.0</span>*a/b &lt; minn) &#123;</span><br><span class="line">            minn = <span class="number">1.0</span>*a/b;</span><br><span class="line">            ans = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%lld&quot;</span>, &amp;j, &amp;x);</span><br><span class="line">        getab(x, j);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P1081&quot;&gt;P1081&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;题目简述&quot;&gt;&lt;a href=&quot;#题目简述&quot; class=&quot;headerlink&quot; title=&quot;题目简述&quot;&gt;&lt;/a&gt;题目简述&lt;/h3&gt;&lt;p&gt;有一排高低不同的城市  &lt;strong&gt;城市距离=高度差&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A和B自左向右开车旅行（出发点可以变）&lt;/p&gt;
&lt;p&gt;A、B的开车风格：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1.A会前往右边距他&lt;strong&gt;第二近&lt;/strong&gt;的城市&lt;br&gt;2.B会前往右边&lt;strong&gt;最近&lt;/strong&gt;的城市&lt;br&gt;3.A和B开过的&lt;strong&gt;总里程&lt;/strong&gt;不超过$X$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;询问:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.给定一个$X$ 求出从哪个城市出发  $A$的路程/$B$的路程  最大&lt;/p&gt;
&lt;p&gt;2.给定$X_i$和出发城市$S_i$ 求$A$和$B$分别开的距离数&lt;/p&gt;
&lt;h3 id=&quot;倍增&quot;&gt;&lt;a href=&quot;#倍增&quot; class=&quot;headerlink&quot; title=&quot;倍增&quot;&gt;&lt;/a&gt;倍增&lt;/h3&gt;&lt;p&gt;在没有修改的&lt;code&gt;RMQ&lt;/code&gt;问题(区间最值问题) 基于&lt;strong&gt;倍增&lt;/strong&gt;的ST表可以做到$O(1)$查询和$O(nlogn)$预处理&lt;/p&gt;
&lt;p&gt;拿最大值来说我们用$Max[i][j]$表示，从$i$位置开始的$2^j$个数中的最大值，例如$Max[i][1]$表示的是$i$位置和$i+1$位置中两个数的最大值(也就是说当前位置是被包含进$2^j$个数去的)&lt;/p&gt;
&lt;p&gt;那么转移的时候我们可以把当前区间拆成两个区间并分别取最大值&lt;/p&gt;
&lt;p&gt;比如&lt;/p&gt;</summary>
    
    
    
    <category term="算法学习" scheme="https://hntr.xyz/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="luogu" scheme="https://hntr.xyz/tags/luogu/"/>
    
    <category term="倍增" scheme="https://hntr.xyz/tags/%E5%80%8D%E5%A2%9E/"/>
    
    <category term="双向链表" scheme="https://hntr.xyz/tags/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>服务站-无权限题目</title>
    <link href="https://hntr.xyz/%E6%9C%8D%E5%8A%A1%E7%AB%99.html"/>
    <id>https://hntr.xyz/%E6%9C%8D%E5%8A%A1%E7%AB%99.html</id>
    <published>2020-08-06T16:00:00.000Z</published>
    <updated>2020-08-15T15:56:01.303Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>渡渡鸟国的每位国民都有一个长度为 $n$ 的身份证号，身份证号的每一位为 $[1,k]$ 内的一个整数。渡渡鸟国现在要设立若干个服务站，每个服务站有一个长度为 $2$ 的编号，每一位也是 $[1,k]$ 内的一个整数。</p><p>对于一只渡渡鸟，设其身份证号为 $s$，其中 $s$ 是一个长度为 $n$ 的字符串。对于一个服务站，设其编号为 $t$，其中 $t$ 是一个长度为 $2$ 的字符串。当且仅当 $t$ 是 $s$ 的子序列时，这只渡渡鸟可以被这个服务站服务。比如 $s=123,t=13$ 时，渡渡鸟可以被服务；而$s=123,t=31$ 时，渡渡鸟不能被服务。</p><p>渡渡鸟国王希望建设一些服务站，使得任意一只渡渡鸟都可以被至少一个服务站服务。它想知道最少需要建造多少个服务站。</p><p>通过并查集 首先最后要分成（k-1）组 然后求步数即可</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;渡渡鸟国的每位国民都有一个长度为 $n$ 的身份证号，身份证号的每一位为 $[1,k]$ 内的一个整数。渡渡鸟国现在要设立若</summary>
      
    
    
    
    <category term="算法学习" scheme="https://hntr.xyz/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="luogu" scheme="https://hntr.xyz/tags/luogu/"/>
    
    <category term="数学" scheme="https://hntr.xyz/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="并查集" scheme="https://hntr.xyz/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>P5023</title>
    <link href="https://hntr.xyz/P5023.html"/>
    <id>https://hntr.xyz/P5023.html</id>
    <published>2020-06-13T12:30:00.000Z</published>
    <updated>2020-07-20T02:04:23.991Z</updated>
    
    <content type="html"><![CDATA[<p>题目描述详见 <a href="https://www.luogu.com.cn/problem/P5023">luogu</a></p><p>题目可以说是非常的长，但是读懂之后概括一下大概就是找到一种填写01的方式，使得任意取两条合法（从$(1,1)$向右向下走到右下角）的路径， 右上路径经过的数字连接成的字符串字典序小。</p><p>然后就是漫长的手模＋找规律</p><p>在模拟$3*3$时，第一次模拟出来的结果非常amazing，竟然有144种<br>在我的理解中，我认为只要是左下-右上走向的线上的数字不递增就可以了<br>如图<br><img src="https://hntr.xyz/img/5023/wrong.png"></p><p>如图$4 \times 4 \times 3 \times 3=144$</p><p>但是显然 这是错误的</p><p>正确解法：</p><a id="more"></a><p>对于上面我的那种天真的想法，这就是一个反例<br><img src="https://hntr.xyz/img/5023/1.png"></p><p>这种交叉的情况下，就要分类讨论</p><p>1.当$n=1$时：</p><p>很明显，答案是$m^{2}$ 这里就不多讨论了。</p><p>2.当$n&gt;1$ 且 $n=m$时</p><p>（$n = 3$）</p><p><img src="https://hntr.xyz/img/5023/2.png"></p><p>图中橙色数字为这一平行线的可能数量， 红色为填入的数字， 蓝色为平行线， 蓝色区域填入的数字必须相等，否则会导致交叉情况出错</p><p>（$n = 4$）</p><p><img src="https://hntr.xyz/img/5023/3.png"></p><p>……</p><p>会发现</p><p>$$<br>ans(3,3) = 2^2 \times 3 \times 4 + 2^4 \times 4 \<br>ans(4,4) = 2^5 \times 5+2^4\times3\times5+2^5\times4^2\<br>ans(5,5) = 2^7\times4\times5+2^5\times3\times5+2^6\times4^3<br>$$</p><p>可得</p><p>$$<br>ans (n,n) = 2^3\cdot ans(n-1, n-1)-5\times2^n<br>$$</p><p>3.当 $n&gt;1$ 且 $n+1=m$时</p><p>$$<br>ans(n,n+1)=3\cdot ans(n,n) - 3\times 2^n<br>$$</p><p>4.当$n&gt;1$且$n+1&lt;m$</p><p>$$<br>ans(n,i)=3\cdot ans(n,i−1)<br>$$</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, mod = <span class="number">1000000007</span>, f[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    f[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">8</span>; i++)</span><br><span class="line">        f[i] = f[i<span class="number">-1</span>] * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; m) swap(n, m);</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>)&#123;</span><br><span class="line">        ans=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">            ans = ans * <span class="number">2</span> % mod;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>) ans = <span class="number">12</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">3</span>) ans = <span class="number">112</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">4</span>) ans = <span class="number">912</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        ans = <span class="number">912</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">5</span>; i &lt;= n; i++)</span><br><span class="line">            ans = ans * <span class="number">8</span> - <span class="number">5</span> * f[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (m == n + <span class="number">1</span> &amp;&amp; n &gt; <span class="number">3</span>)</span><br><span class="line">        ans = ans * <span class="number">3</span> - <span class="number">3</span> * f[n];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">if</span> (m == n + <span class="number">1</span>) ans = ans *<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m &gt; n + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">3</span>)</span><br><span class="line">            ans = ans *<span class="number">3</span> - <span class="number">3</span> * f[n];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ans = ans *<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n + <span class="number">2</span>; i &lt;= m; i++)</span><br><span class="line">            ans = ans * <span class="number">3</span> % mod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（敲完人没了，这比T3还恶心</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;题目描述详见 &lt;a href=&quot;https://www.luogu.com.cn/problem/P5023&quot;&gt;luogu&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;题目可以说是非常的长，但是读懂之后概括一下大概就是找到一种填写01的方式，使得任意取两条合法（从$(1,1)$向右向下走到右下角）的路径， 右上路径经过的数字连接成的字符串字典序小。&lt;/p&gt;
&lt;p&gt;然后就是漫长的手模＋找规律&lt;/p&gt;
&lt;p&gt;在模拟$3*3$时，第一次模拟出来的结果非常amazing，竟然有144种&lt;br&gt;在我的理解中，我认为只要是左下-右上走向的线上的数字不递增就可以了&lt;br&gt;如图&lt;br&gt;&lt;img src=&quot;https://hntr.xyz/img/5023/wrong.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;如图$4 \times 4 \times 3 \times 3=144$&lt;/p&gt;
&lt;p&gt;但是显然 这是错误的&lt;/p&gt;
&lt;p&gt;正确解法：&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="https://hntr.xyz/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="luogu" scheme="https://hntr.xyz/tags/luogu/"/>
    
    <category term="NOIP" scheme="https://hntr.xyz/tags/NOIP/"/>
    
    <category term="DP" scheme="https://hntr.xyz/tags/DP/"/>
    
    <category term="shu数论" scheme="https://hntr.xyz/tags/shu%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>P1969</title>
    <link href="https://hntr.xyz/P1969.html"/>
    <id>https://hntr.xyz/P1969.html</id>
    <published>2020-05-24T07:40:19.000Z</published>
    <updated>2020-05-24T07:49:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>题目描述<br>春春幼儿园举办了一年一度的“积木大赛”。今年比赛的内容是搭建一座宽度为$n$的大厦，大厦可以看成由$n$块宽度为$1$的积木组成，第i块积木的最终高度需要是$h_i$<br>在搭建开始之前，没有任何积木（可以看成nn块高度为$0$的积木）。接下来每次操作，小朋友们可以选择一段连续区间$[l,r]$，然后将第第$L$块到第 $R$ 块之间（含第$L$ 块和第 $R$块）所有积木的高度分别增加$1$。</p><p>小MM是个聪明的小朋友，她很快想出了建造大厦的最佳策略，使得建造所需的操作次数最少。但她不是一个勤于动手的孩子，所以想请你帮忙实现这个策略，并求出最少的操作次数。</p><a id="more"></a><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h4 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, last = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">        <span class="keyword">if</span> (a &gt; last)</span><br><span class="line">            ans += (a - last);</span><br><span class="line">        last = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h4><p>↓ 来自 <a href="https://www.luogu.com.cn/blog/ArthasMenethil/solution-p1969">阿尔萨斯’s题解</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span><span class="comment">//快速读入可有可无</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c=getchar();</span><br><span class="line">    ll s=<span class="number">0</span>,t=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>)t*=<span class="number">-1</span>;</span><br><span class="line">        c=getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        s=s*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        c=getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s*t;</span><br><span class="line">&#125;</span><br><span class="line">ll ans[<span class="number">400004</span>],a[<span class="number">100001</span>],n,answer=<span class="number">0</span>;<span class="comment">//a是每个地方需要搭的高</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">ls</span><span class="params">(ll x)</span><span class="comment">//开始线段树，这是返回左子树的节点值，会线段树的不用看了，线段树打发很多</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&lt;&lt;<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">rs</span><span class="params">(ll x)</span><span class="comment">//右子树</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(ll l,ll r,ll s)</span><span class="comment">//递归建树</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)<span class="comment">//如果触底就返回</span></span><br><span class="line">    &#123;</span><br><span class="line">        ans[s]=l;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ll mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    build(l,mid,ls(s));<span class="comment">//二分建树</span></span><br><span class="line">    build(mid+<span class="number">1</span>,r,rs(s));</span><br><span class="line">    ll s1,s2;</span><br><span class="line">    s1=a[ans[ls(s)]];<span class="comment">//列出左右子树中最低处的高</span></span><br><span class="line">    s2=a[ans[rs(s)]];</span><br><span class="line">    <span class="keyword">if</span>(s1&lt;s2)ans[s]=ans[ls(s)];<span class="comment">//返回最低处</span></span><br><span class="line">    <span class="keyword">else</span> ans[s]=ans[rs(s)];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">find</span><span class="params">(ll s,ll l,ll r,ll xl,ll xr)</span><span class="comment">//注意返回值为位置 ，高度要用a[find(?????)]表示</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(xl&lt;=l&amp;&amp;r&lt;=xr)<span class="keyword">return</span> ans[s];<span class="comment">//如果这个节点应该查询，也就是被查询的左右区间包含，就返回</span></span><br><span class="line">    ll mid=(l+r)&gt;&gt;<span class="number">1</span>,lo,lo2,k;</span><br><span class="line">    <span class="keyword">if</span>(xl&lt;=mid)<span class="comment">//没错就是这里！一定要注意如果该节点左子树不用查询就直接返回右子树的值，否则再比较</span></span><br><span class="line">    &#123;</span><br><span class="line">        lo=find(ls(s),l,mid,xl,xr);<span class="comment">//lo就是左子树中最低点的位置</span></span><br><span class="line">        k=lo;<span class="comment">//用于比较，记录最低点</span></span><br><span class="line">        <span class="keyword">if</span>(mid&lt;xr)</span><br><span class="line">        &#123;</span><br><span class="line">            lo2=find(rs(s),mid+<span class="number">1</span>,r,xl,xr);<span class="comment">//lo2是右子树最低点位置</span></span><br><span class="line">            <span class="keyword">if</span>(a[lo2]&lt;a[lo])k=lo2;<span class="comment">//比较</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//如果没有左子树就直接查询右子树</span></span><br><span class="line">    &#123;</span><br><span class="line">        lo=find(rs(s),mid+<span class="number">1</span>,r,xl,xr);</span><br><span class="line">        k=lo;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(ll l,ll r,ll h)</span><span class="comment">//h是之前的高度</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;r)<span class="keyword">return</span>;<span class="comment">//奇怪的判断，分别判断这个区间是否存在，是否越界*2</span></span><br><span class="line">    <span class="keyword">if</span>(r&lt;<span class="number">1</span>)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;n)<span class="keyword">return</span>;</span><br><span class="line">    ll lo=find(<span class="number">1</span>,<span class="number">1</span>,n,l,r),height;</span><br><span class="line">    height=a[lo];</span><br><span class="line">    answer+=height-h;<span class="comment">//answer加上（当前高度-之前的高度）</span></span><br><span class="line">    f(l,lo<span class="number">-1</span>,height);<span class="comment">//二分</span></span><br><span class="line">    f(lo+<span class="number">1</span>,r,height);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=read();</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++)a[i]=read();</span><br><span class="line">    build(<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">    f(<span class="number">1</span>,n,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;answer;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题目描述&lt;br&gt;春春幼儿园举办了一年一度的“积木大赛”。今年比赛的内容是搭建一座宽度为$n$的大厦，大厦可以看成由$n$块宽度为$1$的积木组成，第i块积木的最终高度需要是$h_i$&lt;br&gt;在搭建开始之前，没有任何积木（可以看成nn块高度为$0$的积木）。接下来每次操作，小朋友们可以选择一段连续区间$[l,r]$，然后将第第$L$块到第 $R$ 块之间（含第$L$ 块和第 $R$块）所有积木的高度分别增加$1$。&lt;/p&gt;
&lt;p&gt;小MM是个聪明的小朋友，她很快想出了建造大厦的最佳策略，使得建造所需的操作次数最少。但她不是一个勤于动手的孩子，所以想请你帮忙实现这个策略，并求出最少的操作次数。&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="https://hntr.xyz/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="luogu" scheme="https://hntr.xyz/tags/luogu/"/>
    
    <category term="贪心" scheme="https://hntr.xyz/tags/%E8%B4%AA%E5%BF%83/"/>
    
    <category term="NOIP" scheme="https://hntr.xyz/tags/NOIP/"/>
    
  </entry>
  
  <entry>
    <title>P5020</title>
    <link href="https://hntr.xyz/P5020.html"/>
    <id>https://hntr.xyz/P5020.html</id>
    <published>2020-05-24T07:15:18.000Z</published>
    <updated>2020-05-24T07:44:12.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P5020">题目链接</a></p><p>详情见愿题目</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100005</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, a[N], maxx, ans, vis[<span class="number">25000</span>], f[<span class="number">25000</span>], t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        maxx = ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">25000</span>; ++i)</span><br><span class="line">            vis[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">            maxx = max(maxx, a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(a + <span class="number">1</span>, a + <span class="number">1</span> + n);<span class="comment">//先排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[a[i]]) <span class="comment">//标记过了，不选</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            ans++; vis[a[i]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = a[i]; k &lt;= maxx; ++k) <span class="comment">//线性筛数</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(vis[k-a[i]])</span><br><span class="line">                    vis[k] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P5020&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;详情见愿题目&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="https://hntr.xyz/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="luogu" scheme="https://hntr.xyz/tags/luogu/"/>
    
    <category term="贪心" scheme="https://hntr.xyz/tags/%E8%B4%AA%E5%BF%83/"/>
    
    <category term="NOIP" scheme="https://hntr.xyz/tags/NOIP/"/>
    
    <category term="DP" scheme="https://hntr.xyz/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>P3951</title>
    <link href="https://hntr.xyz/P3951.html"/>
    <id>https://hntr.xyz/P3951.html</id>
    <published>2020-05-10T08:04:39.000Z</published>
    <updated>2020-05-10T08:17:56.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P3951">题目链接</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>小凯手中有两种面值的金币，两种面值均为正整数且彼此互素。每种金币小凯都有 无数个。在不找零的情况下，仅凭这两种金币，有些物品他是无法准确支付的。现在小 凯想知道在无法准确支付的物品中，最贵的价值是多少金币？注意：输入数据保证存在 小凯无法准确支付的商品。</p><a id="more"></a><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>两个正整数 $a$ 和 $b$，它们之间用一个空格隔开，表示小凯中金币的面值。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>一个正整数 $N$，表示不找零的情况下，小凯用手中的金币不能准确支付的最贵的物品的价值。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>不妨设 $a&lt;b$</p><p>假设答案为 $x$</p><p>若</p><p>$x \equiv ma \pmod b (1 \leq m \leq b - 1)$</p><p>即</p><p>$x = ma + nb (1 \leq m \leq b - 1)$</p><p>显然当 $n \geq 0$时 $x$ 可以用 $a, b$表示出来，不合题意。</p><p>因此当 $n = -1$时 $x$ 取得最大值，此时 $x = ma - b$</p><p>显然当 $m$ 取得最大值 $b - 1$时 $x$ 最大，此时 $x = (b - 1)a - b = ab - a - b$</p><p>因此$ a, b$所表示不出的最大的数是 $ab - a - b$</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> a, b;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, a * b - a - b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P3951&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;小凯手中有两种面值的金币，两种面值均为正整数且彼此互素。每种金币小凯都有 无数个。在不找零的情况下，仅凭这两种金币，有些物品他是无法准确支付的。现在小 凯想知道在无法准确支付的物品中，最贵的价值是多少金币？注意：输入数据保证存在 小凯无法准确支付的商品。&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="https://hntr.xyz/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="luogu" scheme="https://hntr.xyz/tags/luogu/"/>
    
    <category term="数学" scheme="https://hntr.xyz/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="NOIP" scheme="https://hntr.xyz/tags/NOIP/"/>
    
  </entry>
  
  <entry>
    <title>P3952-时间复杂度</title>
    <link href="https://hntr.xyz/P3952.html"/>
    <id>https://hntr.xyz/P3952.html</id>
    <published>2020-05-10T05:50:00.000Z</published>
    <updated>2020-05-10T08:06:32.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P3952">题目链接</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>小明正在学习一种新的编程语言 A++，刚学会循环语句的他激动地写了好多程序并 给出了他自己算出的时间复杂度，可他的编程老师实在不想一个一个检查小明的程序， 于是你的机会来啦！下面请你编写程序来判断小明对他的每个程序给出的时间复杂度是否正确。</p><a id="more"></a><p>原题请至luogu查看</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>代码如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> a, b;</span><br><span class="line"><span class="keyword">int</span> c, d, e, f[<span class="number">27</span>], g[<span class="number">27</span>], h, k, l[<span class="number">100</span>], m, n, o, T;</span><br><span class="line"></span><br><span class="line"><span class="comment">//c是有几个句子，d是题目给的复杂度是多少</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//e是当前在几重循环，f[]是判断变量是否使用过</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//g[]是存下每个循环的变量，h是当前复杂度是多少(与e不同)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//k是判断下面程序是否进行，l[]是存下哪几个循环加了复杂度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//m是当前最大复杂度，n是存下k=1时的循环数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//T是数据组数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span><span class="comment">//初始化 很重要</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    c = <span class="number">0</span>; d = <span class="number">0</span>; m = <span class="number">0</span>; n = <span class="number">0</span>; e = <span class="number">0</span>; h = <span class="number">0</span>; k = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">    <span class="built_in">memset</span>(l, <span class="number">0</span>, <span class="keyword">sizeof</span>(l));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (T--) </span><br><span class="line">    &#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            a = b, <span class="built_in">cin</span> &gt;&gt; b;</span><br><span class="line">        &#125; <span class="keyword">while</span> (b[<span class="number">0</span>] != <span class="string">&#x27;O&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> len_a = a.length();</span><br><span class="line">        <span class="keyword">int</span> len_b = b.length();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len_a; i++)</span><br><span class="line">            c = c * <span class="number">10</span> + a[i] - <span class="number">48</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">4</span>; i &lt; len_b - <span class="number">1</span>; i++)</span><br><span class="line">            d = d * <span class="number">10</span> + b[i] - <span class="number">48</span>; <span class="comment">//取出题目给的时间复杂度 O(1)不影响 </span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (c &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            c--;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a;<span class="comment">//读入F 或 E ,句子数-1</span></span><br><span class="line">            <span class="keyword">if</span> (a[<span class="number">0</span>] == <span class="string">&#x27;F&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                e++; <span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">                <span class="keyword">if</span> (f[a[<span class="number">0</span>] - <span class="number">96</span>]) e = <span class="number">-1</span>;<span class="comment">//如果被用过，标记ERR</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">else</span> <span class="comment">//反之存起来并标记</span></span><br><span class="line"></span><br><span class="line">                    f[a[<span class="number">0</span>] - <span class="number">96</span>] = <span class="number">1</span>, g[e] = a[<span class="number">0</span>] - <span class="number">96</span>;</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">                <span class="keyword">if</span> (a[<span class="number">0</span>] != <span class="string">&#x27;n&#x27;</span>&amp;&amp;b[<span class="number">0</span>] == <span class="string">&#x27;n&#x27;</span>&amp;&amp;k == <span class="number">0</span>)</span><br><span class="line">                    h++, l[e] = <span class="number">1</span>;<span class="comment">//如果a是数字，b是n，而且可以运行，那么当前复杂度+1</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">if</span> (((a.length() == b.length() &amp;&amp; a &gt; b) || (a.length() &gt; b.length()) || (a[<span class="number">0</span>] == <span class="string">&#x27;n&#x27;</span>&amp;&amp;b[<span class="number">0</span>] != <span class="string">&#x27;n&#x27;</span>)) &amp;&amp; k == <span class="number">0</span>) k = <span class="number">1</span>, n = e;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span><span class="comment">//如果是E</span></span><br><span class="line"></span><br><span class="line">            &#123;      </span><br><span class="line">                m = max(m, h); f[g[e]] = <span class="number">0</span>;    <span class="comment">//将最大复杂度更改 ，变量标记没用过   </span></span><br><span class="line">                <span class="keyword">if</span> (l[e] == <span class="number">1</span>) h--, l[e] = <span class="number">0</span>;    </span><br><span class="line">                e--;    </span><br><span class="line">                <span class="keyword">if</span> (n &gt; <span class="number">0</span> &amp;&amp; e &lt; n) </span><br><span class="line">                    k = <span class="number">0</span>, n = <span class="number">0</span>; <span class="comment">//如果当前循环加了复杂度，当前复杂度-1，标记清空 </span></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (e == <span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">&quot;ERR\n&quot;</span>), c = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理结果</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (e &gt; <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;ERR\n&quot;</span>);    </span><br><span class="line">        <span class="keyword">if</span> (e == <span class="number">0</span> &amp;&amp; m == d) <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);   </span><br><span class="line">        <span class="keyword">if</span> (e == <span class="number">0</span> &amp;&amp; m != d) <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>~</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P3952&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;小明正在学习一种新的编程语言 A++，刚学会循环语句的他激动地写了好多程序并 给出了他自己算出的时间复杂度，可他的编程老师实在不想一个一个检查小明的程序， 于是你的机会来啦！下面请你编写程序来判断小明对他的每个程序给出的时间复杂度是否正确。&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="https://hntr.xyz/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="luogu" scheme="https://hntr.xyz/tags/luogu/"/>
    
    <category term="模拟" scheme="https://hntr.xyz/tags/%E6%A8%A1%E6%8B%9F/"/>
    
  </entry>
  
  <entry>
    <title>CSP-S-2019-D1-T2题解</title>
    <link href="https://hntr.xyz/CSP-S-2019-D1-T2.html"/>
    <id>https://hntr.xyz/CSP-S-2019-D1-T2.html</id>
    <published>2020-05-02T14:52:20.000Z</published>
    <updated>2020-05-10T08:05:48.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P5658">题面链接-luogu</a></p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>1.括号序列一定是从<strong>父节点</strong>传递下来的<br>如果用<code>sum[i]</code>表示当前节点的累计，用<code>tail[i]</code>表示以当前节点为结尾的合法字串匹配数量<br>可以得到<br>$sum[x] = sum[fa[x]] + tail[x]$<br>注：<code>fa[x]</code>是<code>x</code>的父节点</p><a id="more"></a><ol start="2"><li>使用栈储存遍历时的信息</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long <span class="comment">//不开ll见</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e5</span> + <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">ll n, tot, ans;</span><br><span class="line"><span class="keyword">int</span> head[maxn], pre[maxn], tree[maxn]; <span class="comment">//链式前向星</span></span><br><span class="line"><span class="keyword">int</span> w[maxn], f[maxn]; <span class="comment">//w是储存节点括号信息 f是父节点信息</span></span><br><span class="line">ll tail[maxn], sum[maxn]; <span class="comment">//tail，sum见上方 </span></span><br><span class="line"><span class="keyword">bool</span> v[maxn]; <span class="comment">//是否已经遍历</span></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tree[++tot] = y;</span><br><span class="line">    pre[tot] = head[x];</span><br><span class="line">    head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (q.size() &amp;&amp; w[q.top()] + w[x] == <span class="number">0</span> &amp;&amp; w[x] == <span class="number">-1</span>)</span><br><span class="line">    <span class="comment">//判断是否是合法的</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//是合法的就将当前tail值更新</span></span><br><span class="line">        tmp = q.top();</span><br><span class="line">        q.pop();</span><br><span class="line">        v[tmp] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        tail[x] = tail[f[tmp]] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        q.push(x), v[x] = <span class="number">1</span>;<span class="comment">//否则继续</span></span><br><span class="line"></span><br><span class="line">    sum[x] = sum[f[x]] + tail[x];<span class="comment">//更新sum</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i=pre[i])<span class="comment">//继续遍历</span></span><br><span class="line">        dfs(tree[i]);</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//复原栈</span></span><br><span class="line">    <span class="keyword">if</span> (v[x])</span><br><span class="line">        q.pop(), v[x] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (tmp)</span><br><span class="line">        q.push(tmp), v[tmp] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> tmp;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; tmp;</span><br><span class="line">        <span class="keyword">if</span> (tmp == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">            w[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            w[i] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;f[i]);</span><br><span class="line">        add(f[i],i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//上方全是输入</span></span><br><span class="line">    </span><br><span class="line">    dfs(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        ans ^= i * sum[i];<span class="comment">//计算答案</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P5658&quot;&gt;题面链接-luogu&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;题解&quot;&gt;&lt;a href=&quot;#题解&quot; class=&quot;headerlink&quot; title=&quot;题解&quot;&gt;&lt;/a&gt;题解&lt;/h3&gt;&lt;p&gt;1.括号序列一定是从&lt;strong&gt;父节点&lt;/strong&gt;传递下来的&lt;br&gt;如果用&lt;code&gt;sum[i]&lt;/code&gt;表示当前节点的累计，用&lt;code&gt;tail[i]&lt;/code&gt;表示以当前节点为结尾的合法字串匹配数量&lt;br&gt;可以得到&lt;br&gt;$sum[x] = sum[fa[x]] + tail[x]$&lt;br&gt;注：&lt;code&gt;fa[x]&lt;/code&gt;是&lt;code&gt;x&lt;/code&gt;的父节点&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="https://hntr.xyz/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="CSP" scheme="https://hntr.xyz/tags/CSP/"/>
    
    <category term="NOIP" scheme="https://hntr.xyz/tags/NOIP/"/>
    
    <category term="树" scheme="https://hntr.xyz/tags/%E6%A0%91/"/>
    
    <category term="栈" scheme="https://hntr.xyz/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>CSP-S-2019-D1-T1题解</title>
    <link href="https://hntr.xyz/CSP-S-2019-D1-T1.html"/>
    <id>https://hntr.xyz/CSP-S-2019-D1-T1.html</id>
    <published>2020-05-02T14:52:09.000Z</published>
    <updated>2020-05-10T08:05:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>格雷码（Gray Code）是一种特殊的 $n$ 位二进制串排列法，它要求相邻的两个二进制串间恰好有一位不同，特别地，第一个串与最后一个串也算作相邻。</p><p>………………</p><p>现在给出 $n$，$k$，请你求出按上述算法生成的 $n$ 位格雷码中的$k$ 号二进制串。</p><a id="more"></a><p>直接找规律</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><a href="https://www.luogu.com.cn/record/28289339">提交记录</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ull n,k;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line"></span><br><span class="line">    k^=k &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(n)</span><br><span class="line">    &#123;</span><br><span class="line">        n--;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (k &gt;&gt; n &amp; <span class="number">1</span>); <span class="comment">//硬核找规律</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;格雷码（Gray Code）是一种特殊的 $n$ 位二进制串排列法，它要求相邻的两个二进制串间恰好有一位不同，特别地，第一个串与最后一个串也算作相邻。&lt;/p&gt;
&lt;p&gt;………………&lt;/p&gt;
&lt;p&gt;现在给出 $n$，$k$，请你求出按上述算法生成的 $n$ 位格雷码中的$k$ 号二进制串。&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="https://hntr.xyz/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="CSP" scheme="https://hntr.xyz/tags/CSP/"/>
    
    <category term="模拟" scheme="https://hntr.xyz/tags/%E6%A8%A1%E6%8B%9F/"/>
    
    <category term="数学" scheme="https://hntr.xyz/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="NOIP" scheme="https://hntr.xyz/tags/NOIP/"/>
    
  </entry>
  
  <entry>
    <title>查看qq好友的ip</title>
    <link href="https://hntr.xyz/ip.html"/>
    <id>https://hntr.xyz/ip.html</id>
    <published>2020-02-19T06:00:48.000Z</published>
    <updated>2020-02-19T10:01:06.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong><font color = red>注意：请合理使用此教程，因为不正当使用造成的后果自负！</font></strong></p><p>如何通过QQ获取别人的ip地址，并通过ip查询对方的地址</p><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>以下操作须在电脑端操作。</p><p>首先，你需要下载软件，下载地址：</p><p>链接: <a href="https://pan.baidu.com/s/1QSJGlfpzMhG18810w_1wMg">https://pan.baidu.com/s/1QSJGlfpzMhG18810w_1wMg</a> 提取码: yr7p</p><h3 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h3><p>下载完成后，你将得到一个压缩包，将其解压到D盘（其他地方也可以，但你要记住放在了哪里）。</p><blockquote><p>解压密码： showip</p></blockquote><p>解压完成后是这样一个文件夹，点击进入。<br><img src="https://i.loli.net/2020/02/19/lcy45dktMsjI2zi.png" alt="image.png"></p><p>右键点击这个文件夹中的<code>木子李QQ安装</code>文件</p><p><img src="https://i.loli.net/2020/02/19/8h6YBJnMkNWODza.png" alt="image.png"></p><p>选择<code>以管理员身份运行</code><br>弹出如下窗口，注意，如果没有以管理员权限运行将会报错。</p><p><img src="https://i.loli.net/2020/02/19/WwtzbqeIYmfva72.png" alt="image.png"></p><p>按提示，输入1，并按下回车，程序将完成此版本QQ的安装。</p><h3 id="获取对方ip"><a href="#获取对方ip" class="headerlink" title="获取对方ip"></a>获取对方ip</h3><p>完成以上安装步骤后，进入下图所示的<code>bin</code>文件夹。</p><p><img src="https://i.loli.net/2020/02/19/g1xDfPEOLCmtv5F.png" alt="image.png"></p><p>找到<code>QQ</code>或<code>QQ.exe</code>（一般情况下是<code>QQ</code>）如下图<br><img src="https://i.loli.net/2020/02/19/LtOzJwigDRHTSaX.png" alt="image.png"></p><p>点击打开此版本QQ<br>登录<br><img src="https://i.loli.net/2020/02/19/ixdE56CJr8SuFwX.png" alt="image.png"></p><p>登陆完成后打开与好友的聊天</p><p>这一步，根据提示，需要给好友传输在线文件或者远程演示。</p><p>可以选择一些文件，建议大于<code>15MB</code>以便可以更稳定的获取ip，并且容易在文件传输完成前点击转在线发送</p><p>比如一首歌曲，如下图所示，点击<code>转在线发送</code>（如果已经是在线发送了就不用点<code>转离线发送</code>了）</p><p><img src="https://i.loli.net/2020/02/19/dMJwlWcy4pBe8Q6.png" alt="image.png"></p><p>这里文件比较小，所以点了两次才点到，不要学我<del>作死</del>，容易出问题</p><p>传输完成后就可以看到ip了（如下图）：</p><p><img src="https://i.loli.net/2020/02/19/zSfQLNiITOUFRJm.png" alt="image.png"></p><h3 id="ip的运用（查找地址）"><a href="#ip的运用（查找地址）" class="headerlink" title="ip的运用（查找地址）"></a>ip的运用（查找地址）</h3><p>得到了ip之后，就可以查询一些基本的信息了，比如运营商、地址等等。<br>进入这个网站：<a href="https://www.ipplus360.com/">IP问问</a></p><p><img src="https://i.loli.net/2020/02/19/IWaRxK7OnudNpMc.png" alt="image.png"></p><p>点击输入刚才查找到的ip，如上图，<br>点击查询后即可看到一些基本信息（已打码）：</p><p><img src="https://i.loli.net/2020/02/19/LSEAiVDW9pecJ3r.png" alt="image.png"></p><p>同时可以看到下方的地图，点击<br><img src="https://i.loli.net/2020/02/19/BfbqExOMAZ6Yt2N.png" alt="image.png"><br>公安版数据<br>可以查看更精准的定位</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总之就是一个软件的妙用。</p><p>千万不要拿来干坏事😝</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;&lt;font color = red&gt;注意：请合理使用此教程，因为不正当使用造成的后果自负！&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如何通过QQ获取别人的ip地址，并通过ip查询对方的地址&lt;/p&gt;
&lt;h3 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工</summary>
      
    
    
    
    <category term="技巧" scheme="https://hntr.xyz/categories/%E6%8A%80%E5%B7%A7/"/>
    
    
  </entry>
  
  <entry>
    <title>woaw</title>
    <link href="https://hntr.xyz/tr.html"/>
    <id>https://hntr.xyz/tr.html</id>
    <published>2020-02-17T13:59:54.000Z</published>
    <updated>2020-02-17T14:11:42.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong><font size=5px color=#ff7575>首先祝陶融大大生日快乐！</font></strong></p><p>祝你生日快乐，祝你生日快乐，祝你生日快乐eeee（乐的长音），祝你生日快乐。</p><p>祝你在新的一岁里，一切的快乐,一切的温馨,一切的感动，一切的好运永远围绕在你的身边!祝你魅力十足、才高八斗、欧气爆棚~~</p><p>🍕🍔🍟🌭🍿🍳🧇🥞🍞🥯🥗🥪🌮这是怎么吃都吃不胖的分割线🍖🥩🥟🥠🍘🍙🍛🍣🍤🍝🥤🍦🍭</p><hr><p>下面是来自qhx的纯属bb的话：</p><p>当时是在过年的时候吧，我正在挨家挨户送祝福，突然，tr大大跟我说要和我绑闺蜜，我当场懵逼，我是谁，我在哪，我要干什么，为啥要跟我绑闺蜜。然后我愣了好久，然后才点了同意，然后还是很开心的，反正就觉得挺好的，可以分享各种<del>奇奇怪怪的</del>事情。然后事实证明，确实很快乐啊！！收获了超多的快乐和interesting的东西<del>~<br>其实在我原本（很早很早）的印象里我以为tr一直是一个无比认真、无比专注的学霸（真的，可能是我太菜了叭😭)，然后后来发现其实并不完全是，但是有的地方u1s1确实很nb，比如确实是一个学霸，真的真的我就是这么认为的<img src="https://i.loli.net/2020/02/17/fO3wGlDvRzBstuV.jpg" alt="@58@_N_DQ@YC4RVW04Q0@Z5.jpg"><br>但是也确实是一个非常……（？我真的不知道怎么形容，感觉词汇被掏空啥也不知道，就是你能想到的夸你的词）的</del>沙雕~~女孩。看来以后我还是要和人多交流，不然咋知道谁是一个什么样美好的人呢（其实我就是怂555）。这个寒假分享了好多快乐的事情，也收获了好多好多的欢乐，反正就是灰常emm amazing！！！每天都能发现打心底的快乐，总之就是我那股子沙雕劲被激发出来了（雾 大雾）<br>希望我们还可以继续快乐分享每一天（怎么感觉像个广告词 雾）</p><p>总之，<br>祝你每天都很快乐ο(=•ω＜=)ρ⌒☆，<br>实现所有的小梦想(ง •_•)ง，<br>然后祝你找一个帅帅帅的npy（如果你想的话( •̀ ω •́ )✧）<br>吃啥都不胖（最真诚的祝福ヾ(≧ ▽ ≦)ゝ）</p><p><font size=6px color=#ff7575>生日快乐！！！🎂</font></p><p>2020 干杯！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;&lt;font size=5px color=#ff7575&gt;首先祝陶融大大生日快乐！&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;祝你生日快乐，祝你生日快乐，祝你生日快乐eeee（乐的长音），祝你生日快乐。&lt;/p&gt;
&lt;p&gt;祝你在新的一岁里，一切的快乐,一切的</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>P2286[HNOI2004]题解</title>
    <link href="https://hntr.xyz/P2286[HNOI2004]%E9%A2%98%E8%A7%A3.html"/>
    <id>https://hntr.xyz/P2286[HNOI2004]%E9%A2%98%E8%A7%A3.html</id>
    <published>2020-02-03T14:41:00.000Z</published>
    <updated>2020-02-11T09:39:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>这道题目可以算是一道<code>set</code>的板子题（在CJC大佬的提醒下恍然大悟，<a href="https://www.luogu.com.cn/blog/L-O-A-T-R-Iridescent/">CJC的博客</a>），于是这篇题解某种意义上其实是对于<code>set</code>的讲解和复习。关于<code>STL</code>的话，全称为<code>Standard Template Library</code>，说白了就是一个非常多功能的库，引用时按情况引用，可能会有<code>set</code> <code>map</code> <code>algorithm</code>等等，按情况来分析，用途很多，有封装好的快排、大根小根堆（优先队列）、二分查找、全排列、各种神仙玩意儿。<code>set</code>则是其中的一个工具。</p><a id="more"></a><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p><code>set</code>和<code>multiset</code>的区别是，后者可以有重复的元素，前者不可以。<br><code>set</code>插入重复元素可能会不成功，所以有重复元素要用<code>multiset</code>。<br>用法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt; //set所在的库</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; st; <span class="comment">//定义方法，其他类型类似</span></span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">10</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">12</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">        st.insert(a[i]);<span class="comment">//插入方式</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; st.size() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//st.size()返回这个set的大小，整形</span></span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator i; <span class="comment">//迭代器，类似于一个指向set中某个元素的指针，不可以比较大小，不可以相加相减，但可以++i（迭代）</span></span><br><span class="line">    <span class="keyword">for</span> (i = st.begin(); i != st.snd(); ++i) <span class="comment">//由于迭代器的特殊性，只能用这种方式进行循环</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; * i &lt;&lt; <span class="string">&quot;,&quot;</span>; </span><br><span class="line">    <span class="built_in">cout</span> <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">pair</span>&lt;<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator, <span class="keyword">bool</span>&gt; result = st.insert(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (!result.second)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; * result.first &lt;&lt; <span class="string">&quot; already exists.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; * result.first &lt;&lt; <span class="string">&quot; inserted.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多的关于<code>set</code>的用法和函数详解，可以访问<a href="http://www.cplusplus.com/reference/">C++ reference</a></p><h3 id="这道题目"><a href="#这道题目" class="headerlink" title="这道题目"></a>这道题目</h3><p>题目简述：<br>凡凡开了一间宠物收养场。收养场提供两种服务：收养被主人遗弃的宠物和让新的主人领养这些宠物。</p><p>每个领养者都希望领养到自己满意的宠物，凡凡根据领养者的要求通过他自己发明的一个特殊的公式，得出该领养者希望领养的宠物的特点值$a$（$a$是一个正整数，$a&lt;2^{31}$），而他也给每个处在收养场的宠物一个特点值。这样他就能够很方便的处理整个领养宠物的过程了，宠物收养场总是会有两种情况发生：被遗弃的宠物过多或者是想要收养宠物的人太多，而宠物太少。</p><p>被遗弃的宠物过多时，假若到来一个领养者，这个领养者希望领养的宠物的特点值为$a$，那么它将会领养一只目前未被领养的宠物中特点值最接近$a$的一只宠物。（任何两只宠物的特点值都不可能是相同的，任何两个领养者的希望领养宠物的特点值也不可能是一样的）如果有两只满足要求的宠物，即存在两只宠物他们的特点值分别为$a-b$和$a+b$，那么领养者将会领养特点值为$a-b$的那只宠物。</p><p>收养宠物的人过多，假若到来一只被收养的宠物，那么哪个领养者能够领养它呢？能够领养它的领养者，是那个希望被领养宠物的特点值最接近该宠物特点值的领养者，如果该宠物的特点值为$a$，存在两个领养者他们希望领养宠物的特点值分别为$a-b$和$a+b$，那么特点值为$a-b$的那个领养者将成功领养该宠物。</p><p>一个领养者领养了一个特点值为$a$的宠物，而它本身希望领养的宠物的特点值为$b$，那么这个领养者的不满意程度为$abs(a-b)$。</p><p>你得到了一年当中，领养者和被收养宠物到来收养所的情况，请你计算所有收养了宠物的领养者的不满意程度的总和。这一年初始时，收养所里面既没有宠物，也没有领养者。</p><p>问题解决：</p><p>知道了<code>set</code>怎么用，辣么就好办了（好像还要知道一个<code>lower_bound()</code>）</p><p>我们只要把每次宠物的编号插入，然后直接查询，查询的话也是用<code>STL</code>中的<code>lower_bound</code>和<code>uper_bound</code>，然后这道题目就可以A了</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt; //万能头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_INT = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, ans;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s; <span class="comment">//定义set</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator left, right;<span class="comment">//定义迭代器</span></span><br><span class="line">    left = --s.lower_bound(x);</span><br><span class="line">    right = s.lower_bound(x);</span><br><span class="line">    <span class="keyword">if</span> (x - *left &lt;= *right - x &amp;&amp; *left != -MAX_INT)</span><br><span class="line">    &#123;</span><br><span class="line">        ans += x - *left;</span><br><span class="line">        s.erase(left);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ans += *right - x;</span><br><span class="line">        s.erase(right);</span><br><span class="line">    &#125;</span><br><span class="line">    ans %= <span class="number">1000000</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">int</span> hod;</span><br><span class="line">    s.insert(-MAX_INT), s.insert(MAX_INT); <span class="comment">//通过插入最大整型和最小整型来防止查找溢出，这是一位大佬的方法，非常秒！！</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="keyword">if</span> (s.size() == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            hod = a;</span><br><span class="line">            s.insert(b);</span><br><span class="line">        &#125; <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">if</span> (a == hod) </span><br><span class="line">                s.insert(b); <span class="keyword">else</span> find(b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>完事儿~<br>考虑在写一个关于STL的整合，这一切都要从一只🦇说起……</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这道题目可以算是一道&lt;code&gt;set&lt;/code&gt;的板子题（在CJC大佬的提醒下恍然大悟，&lt;a href=&quot;https://www.luogu.com.cn/blog/L-O-A-T-R-Iridescent/&quot;&gt;CJC的博客&lt;/a&gt;），于是这篇题解某种意义上其实是对于&lt;code&gt;set&lt;/code&gt;的讲解和复习。关于&lt;code&gt;STL&lt;/code&gt;的话，全称为&lt;code&gt;Standard Template Library&lt;/code&gt;，说白了就是一个非常多功能的库，引用时按情况引用，可能会有&lt;code&gt;set&lt;/code&gt; &lt;code&gt;map&lt;/code&gt; &lt;code&gt;algorithm&lt;/code&gt;等等，按情况来分析，用途很多，有封装好的快排、大根小根堆（优先队列）、二分查找、全排列、各种神仙玩意儿。&lt;code&gt;set&lt;/code&gt;则是其中的一个工具。&lt;/p&gt;</summary>
    
    
    
    <category term="算法学习" scheme="https://hntr.xyz/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="luogu" scheme="https://hntr.xyz/tags/luogu/"/>
    
    <category term="STL" scheme="https://hntr.xyz/tags/STL/"/>
    
    <category term="set" scheme="https://hntr.xyz/tags/set/"/>
    
  </entry>
  
  <entry>
    <title>LCA最近公共祖先</title>
    <link href="https://hntr.xyz/LCA%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html"/>
    <id>https://hntr.xyz/LCA%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html</id>
    <published>2020-01-21T16:00:00.000Z</published>
    <updated>2020-02-16T12:15:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>学习了 <code>LCA（最近公共祖先）</code> 这个高级的东西。。<br>于是乎来发一些理解和题解以便以后复习。</p><h3 id="什么是LCA"><a href="#什么是LCA" class="headerlink" title="什么是LCA"></a>什么是LCA</h3><p><del>LCA就是LCA</del><br>就是求一棵树上两个节点最近的公共祖先，那么有什么用呢，用来做题。</p><h3 id="LCA的实现"><a href="#LCA的实现" class="headerlink" title="LCA的实现"></a>LCA的实现</h3><p>这里用到了“爬树”的方法找<br>例如两个节点$x,y$:<br>规定$deepth_x&gt;deepth_y$<br>1.让深的那个节点,$x$往树上爬，直到$deepth_x = deepth_y$；<br>2.让两个节点一起向上跳，如果碰在一起了，那么就找到了。<br>嗯，真是生动形象<del>好理解</del>呢！</p><a id="more"></a><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h4><p>一种神奇的存树、图的方式：<br><code>edge[cnt]</code>数组存储了第<code>cnt</code>条边，其中<code>to</code>表示这条边指向的节点;<code>pr</code>e则是指同一个点出发，比当前点早一个添加的<code>边的编号</code>，别的大佬好像是用<code>nxt</code>。<br><code>head[x]</code>存储了从<code>x</code>出发的所有边中最近添加的边<br>感受一下，会懂的😉</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> head[MAXN];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, pre;</span><br><span class="line">&#125;edge[(MAXN) * <span class="number">2</span>];</span><br></pre></td></tr></table></figure><h4 id="增加边"><a href="#增加边" class="headerlink" title="增加边"></a>增加边</h4><p>有了之上的存储方式，那么就有了下面的加边方法（<code>cnt</code>初始为0）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//edge[++cnt].to = y;</span></span><br><span class="line">    <span class="comment">//edge[cnt].pre = head[x];</span></span><br><span class="line">    edge[++cnt] = (Node)&#123;head[x], y&#125;;<span class="comment">//这句和上面两句一样，但它压行了</span></span><br><span class="line">    head[x] = cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>深搜初始化<code>deepth</code>数组（每个节点在树中的深度）；<br>利用倍增思想，类似<code>st</code>表的方式，预处理<code>father</code>数组：<br>$father[x][i]$表示$x$节点向上爬$2^i$后的位置<br>更新方程式：<br>$father[now][i] = father[father[now][i - 1]][i - 1];$<br>解释：现在向上爬$2^i$的位置等于向上爬$2^{i-1}$再向上爬$2^{i-1}$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    father[now][<span class="number">0</span>] = fa;</span><br><span class="line">    deepth[now] = deepth[fa] + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; (<span class="number">1</span> &lt;&lt; i) &lt;= deepth[now]; ++i)</span><br><span class="line">        father[now][i] = father[father[now][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = head[now]; i; i = edge[i].pre)</span><br><span class="line">        <span class="keyword">if</span> (edge[i].to != fa)<span class="comment">//遍历下一条边，只要不是指向他父亲的就继续</span></span><br><span class="line">            build(edge[i].to, now);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><p>lca的关键部分,<br>看代码挺好理解的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (depth[x] &lt; depth[y])<span class="comment">//方便起见，规定x总比y深，不然换一下</span></span><br><span class="line">        swap(x, y);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">29</span>; i &gt;= <span class="number">0</span>; --i)<span class="comment">//让x向上爬，但不能比y浅，这里可以直接像我这样暴力30次，没有关系</span></span><br><span class="line">        <span class="keyword">if</span> (depth[father[x][i]] &gt;= depth[y])</span><br><span class="line">            x = father[x][i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x == y) <span class="keyword">return</span> x;<span class="comment">//特判</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">29</span>; i &gt;= <span class="number">0</span>; --i)<span class="comment">//xy一起向上跳</span></span><br><span class="line">        <span class="keyword">if</span> (father[x][i] != father[y][i])</span><br><span class="line">        &#123;</span><br><span class="line">            x = father[x][i];</span><br><span class="line">            y = father[y][i];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> father[x][<span class="number">0</span>];<span class="comment">//最后返回x节点上一层的节点，即为最近公共祖先</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总的代码"><a href="#总的代码" class="headerlink" title="总的代码"></a>总的代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 500000 + 9</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>, n, m, s;</span><br><span class="line"><span class="keyword">int</span> father[MAXN][<span class="number">30</span>], head[MAXN], depth[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, pre;</span><br><span class="line">&#125;edge[(MAXN) * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[++cnt].to = y;</span><br><span class="line">    edge[cnt].pre = head[x];</span><br><span class="line">    head[x] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    father[now][<span class="number">0</span>] = fa;</span><br><span class="line">    depth[now] = depth[fa] + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; (<span class="number">1</span> &lt;&lt; i) &lt;= depth[now]; ++i)</span><br><span class="line">        father[now][i] = father[father[now][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = head[now]; i; i = edge[i].pre)</span><br><span class="line">        <span class="keyword">if</span> (edge[i].to != fa)</span><br><span class="line">            dfs(edge[i].to, now);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (depth[x] &lt; depth[y])</span><br><span class="line">        swap(x, y);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">29</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        <span class="keyword">if</span> (depth[father[x][i]] &gt;= depth[y])</span><br><span class="line">            x = father[x][i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x == y) <span class="keyword">return</span> x;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">29</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        <span class="keyword">if</span> (father[x][i] != father[y][i])</span><br><span class="line">        &#123;</span><br><span class="line">            x = father[x][i];</span><br><span class="line">            y = father[y][i];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> father[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        addedge(a, b);</span><br><span class="line">        addedge(b, a);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(s, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, lca(a, b));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>完事儿<br>peace~</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;学习了 &lt;code&gt;LCA（最近公共祖先）&lt;/code&gt; 这个高级的东西。。&lt;br&gt;于是乎来发一些理解和题解以便以后复习。&lt;/p&gt;
&lt;h3 id=&quot;什么是LCA&quot;&gt;&lt;a href=&quot;#什么是LCA&quot; class=&quot;headerlink&quot; title=&quot;什么是LCA&quot;&gt;&lt;/a&gt;什么是LCA&lt;/h3&gt;&lt;p&gt;&lt;del&gt;LCA就是LCA&lt;/del&gt;&lt;br&gt;就是求一棵树上两个节点最近的公共祖先，那么有什么用呢，用来做题。&lt;/p&gt;
&lt;h3 id=&quot;LCA的实现&quot;&gt;&lt;a href=&quot;#LCA的实现&quot; class=&quot;headerlink&quot; title=&quot;LCA的实现&quot;&gt;&lt;/a&gt;LCA的实现&lt;/h3&gt;&lt;p&gt;这里用到了“爬树”的方法找&lt;br&gt;例如两个节点$x,y$:&lt;br&gt;规定$deepth_x&amp;gt;deepth_y$&lt;br&gt;1.让深的那个节点,$x$往树上爬，直到$deepth_x = deepth_y$；&lt;br&gt;2.让两个节点一起向上跳，如果碰在一起了，那么就找到了。&lt;br&gt;嗯，真是生动形象&lt;del&gt;好理解&lt;/del&gt;呢！&lt;/p&gt;</summary>
    
    
    
    <category term="算法学习" scheme="https://hntr.xyz/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="luogu" scheme="https://hntr.xyz/tags/luogu/"/>
    
    <category term="LCA" scheme="https://hntr.xyz/tags/LCA/"/>
    
    <category term="倍增" scheme="https://hntr.xyz/tags/%E5%80%8D%E5%A2%9E/"/>
    
  </entry>
  
  <entry>
    <title>ST表</title>
    <link href="https://hntr.xyz/ST%E8%A1%A8.html"/>
    <id>https://hntr.xyz/ST%E8%A1%A8.html</id>
    <published>2020-01-20T16:00:00.000Z</published>
    <updated>2020-02-02T15:26:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>学习了 <code>ST表</code> 这个高级的东西。。<br>于是乎来发一些理解和题解以便以后复习。</p><h3 id="什么是ST表"><a href="#什么是ST表" class="headerlink" title="什么是ST表"></a>什么是ST表</h3><p>ST表的功能很简单：<br>它是解决<code>RMQ</code>问题(区间最值问题)的一种强有力的工具。<br>它可以做到$O(nlogn)$预处理，$O(1)$查询最值（ohhhhhhhh）</p><a id="more"></a><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>怎么做到的呢，它运用了<code>倍增</code>的思想。</p><p>拿最大值来说我们用$Max[i][j]$表示，从$i$位置开始的$2^j$个数中的最大值，例如$Max[i][1]$表示的是$i$位置和$i+1$位置中两个数的最大值(也就是说当前位置是被包含进$2^j$个数去的)</p><p>那么转移的时候我们可以把当前区间拆成两个区间并分别取最大值（注意这里的编号是从$1$开始的）</p><p><img src="https://hntr.xyz/img/st/transfer.jpg" alt="transfer"></p><p>查询的时候也比较简单<br>我们计算出$log_2{lenth}$,然后对于左端点和右端点分别进行查询，这样可以保证一定可以覆盖查询的区间</p><p><img src="https://hntr.xyz/img/st/ask.jpg" alt="transfer"></p><p>所以就有了这两个边界，$[l,l+2^k-1]$, $[r-2^k+1,r]$<br>至于为什么会是$[r-2^k+1,r]$，你只要设左端点为$x$, 并且$x$满足$x + 2^k - 1 = r$, 然后就可以推出来了。</p><h3 id="例题和代码"><a href="#例题和代码" class="headerlink" title="例题和代码"></a>例题和代码</h3><p>给定一个长度为 $N$ 的数列，和 $M$ 次询问，求出每一次询问的区间内数字的最大值。</p><p>上代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxN 100000 + 9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LogN 17 <span class="comment">//顶多2的17次方就可以从左端到最右端了</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[MaxN][LogN], n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="comment">//快读 很容易暴毙</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c=getchar();<span class="keyword">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">-1</span>;c=getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=getchar();&#125;</span><br><span class="line">    <span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// x + (1 &lt;&lt; len) - 1=r 草稿请无视🤣</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = log2(r - l + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> max(f[l][len], f[r - (<span class="number">1</span> &lt;&lt; len) + <span class="number">1</span>][len]); <span class="comment">//关键，这样可以保证覆盖需要查询的区间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read(); m = read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        f[i][<span class="number">0</span>] = read();<span class="comment">//预处理的时候存在0的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">21</span>; ++j)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= n; ++i)</span><br><span class="line">            f[i][j] = max(f[i][j - <span class="number">1</span>], f[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]); <span class="comment">//转移方程式</span></span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        a = read(); b = read();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ask(a, b));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嗯，没有四倍经验。<br>peace~</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;学习了 &lt;code&gt;ST表&lt;/code&gt; 这个高级的东西。。&lt;br&gt;于是乎来发一些理解和题解以便以后复习。&lt;/p&gt;
&lt;h3 id=&quot;什么是ST表&quot;&gt;&lt;a href=&quot;#什么是ST表&quot; class=&quot;headerlink&quot; title=&quot;什么是ST表&quot;&gt;&lt;/a&gt;什么是ST表&lt;/h3&gt;&lt;p&gt;ST表的功能很简单：&lt;br&gt;它是解决&lt;code&gt;RMQ&lt;/code&gt;问题(区间最值问题)的一种强有力的工具。&lt;br&gt;它可以做到$O(nlogn)$预处理，$O(1)$查询最值（ohhhhhhhh）&lt;/p&gt;</summary>
    
    
    
    <category term="算法学习" scheme="https://hntr.xyz/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="luogu" scheme="https://hntr.xyz/tags/luogu/"/>
    
    <category term="倍增" scheme="https://hntr.xyz/tags/%E5%80%8D%E5%A2%9E/"/>
    
    <category term="ST表" scheme="https://hntr.xyz/tags/ST%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>线段树</title>
    <link href="https://hntr.xyz/%E7%BA%BF%E6%AE%B5%E6%A0%91.html"/>
    <id>https://hntr.xyz/%E7%BA%BF%E6%AE%B5%E6%A0%91.html</id>
    <published>2020-01-19T16:00:00.000Z</published>
    <updated>2020-02-01T13:19:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>这两节课学习了 <code>线段树</code> 这个高级的东西。。<br>于是乎来发一些理解和题解以便以后复习。</p><h3 id="什么是线段树"><a href="#什么是线段树" class="headerlink" title="什么是线段树"></a>什么是线段树</h3><p>先来康康这类问题：<br>长度为$n$的数列${a_1, a_2, … , a_n}$<br>（1）求最值：给定$i$,$j&lt;=n$，求${a_i, …, a_j}$区间内的最值。<br>（2）修改元素：给定$k$和$x$，把$a_k$改成$x$。<br>显然你可以用<del>暴力</del>去做，但是</p><a id="more"></a><p>如果在加一些操作，比如<br>（3）给定$n$个元素${a_1, a_2, … , a_n} $：<br>• 加：给定$i, j&lt;=n$，把${a_i, …, a_j}$区间内的每个元素加$v$。<br>• 查询：给定$L, R&lt;=n$，计算${a_L, …, a_R}$的区间和。</p><p>那么暴力就暴毙。。。</p><p>于是就讲了线段树。<br>大概长这个样子：<br><img src="https://hunterqu.github.io/img/xds/xds.jpg" alt="xds"><br>他的每个节点都含有l和r代表了它这个节点所代表的线段或者说是区间， 所以一颗线段树就可以把一根线（一个区间）分成线段（子区间），就比如上面这颗。<br>对于解决区间最值的问题，每个节点多出一个<code>num</code>去存储当前区间的最值即可。<br>然后我们来看操作。</p><h3 id="线段树的基本操作"><a href="#线段树的基本操作" class="headerlink" title="线段树的基本操作"></a>线段树的基本操作</h3><p>首先我们来看个例题，<a href="https://www.luogu.com.cn/problem/P3374">Luogu P3374 </a></p><h4 id="例题1题面"><a href="#例题1题面" class="headerlink" title="例题1题面"></a>例题1题面</h4><h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>如题，已知一个数列，你需要进行下面两种操作：</p><p>将某一个数加上 $x$</p><p>求出某区间每一个数的和</p><h5 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h5><p>第一行包含两个正整数 $n,m$，分别表示该数列数字的个数和操作的总个数。</p><p>第二行包含 $n$ 个用空格分隔的整数，其中第 $i$ 个数字表示数列第 $i$ 项的初始值。</p><p>接下来 $m$ 行每行包含 $3$ 个整数，表示一个操作，具体如下：</p><p><code>1 x k</code> 含义：将第 $x$ 个数加上 $k$</p><p><code>2 x y</code> 含义：输出区间 $[x,y]$内每个数的和</p><h5 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h5><p>输出包含若干行整数，即为所有操作 $2$ 的结果。</p><p>这是luogu的线段树模板题1，涉及的操作有<code>建树</code>、<code>修改单点</code>、<code>查询区间和</code></p><h4 id="例题2题面"><a href="#例题2题面" class="headerlink" title="例题2题面"></a>例题2题面</h4><h5 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h5><p>如题，已知一个数列，你需要进行下面两种操作：</p><p>1.将某区间每一个数加上x</p><p>2.求出某区间每一个数的和</p><p>涉及的操作<strong>还有</strong> <code>区间修改</code></p><h4 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h4><h5 id="建树"><a href="#建树" class="headerlink" title="建树"></a>建树</h5><p>首先线段树是存在数组里的，数组每一个都是一个结构体<br>注意因为是数组存树，所以要开4被MAXN</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r; <span class="comment">//表示区间左右端点</span></span><br><span class="line">    <span class="keyword">int</span> sum; <span class="comment">//在本题中sum表示此区间内所有的和</span></span><br><span class="line">&#125;tree[<span class="number">4</span> * MaxN];</span><br></pre></td></tr></table></figure><p>然后就是建树</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> <span class="comment">// index指的是当前节点在tree数组中的位置</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tree[index].l = l;</span><br><span class="line">    tree[index].r = r;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="comment">//如果左右端点一样说明他是一个点，更新sum为输入的值</span></span><br><span class="line">        &#123;</span><br><span class="line">            tree[index].sum = input[l]; <span class="comment">// input是输入的数组</span></span><br><span class="line">            <span class="keyword">return</span> input[l];</span><br><span class="line">        &#125;</span><br><span class="line">    tree[index].sum = build(lson, l, (l + r) &gt;&gt; <span class="number">1</span>) + build(rson, ((l + r) &gt;&gt; <span class="number">1</span>) + <span class="number">1</span>, r); <span class="comment">//递归继续建树</span></span><br><span class="line">    <span class="keyword">return</span> tree[index].sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="单点修改"><a href="#单点修改" class="headerlink" title="单点修改"></a>单点修改</h5><p>其实后来发现没啥用， 因为可以用区间修改的函数，l=r</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> x, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tree[index].sum += k;<span class="comment">//只要是遍历到的节点都要加K</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tree[index].l == tree[index].r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x &lt;= tree[index &lt;&lt; <span class="number">1</span>].r) <span class="comment">//遍历左子树</span></span><br><span class="line">        add(index &lt;&lt; <span class="number">1</span>, x, k);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x &gt;= tree[(index &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>].l) <span class="comment">//遍历右子树  index &lt;&lt; 1 等价于 index * 2 但是位运算更快</span></span><br><span class="line">        add((index &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>, x, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="区间查询（无懒标记）"><a href="#区间查询（无懒标记）" class="headerlink" title="区间查询（无懒标记）"></a>区间查询（无懒标记）</h5><p>区间查询就是，每查到一个区间，有三种选择：</p><p>1、如果这个区间被完全包括在目标区间内，那么加上这个区间的和，然后return；</p><p>2、如果这个区间的right&gt;目标区间的left，那么查询这个区间；</p><p>3、如果这个区间的left&lt;目标区间的right，也查询这个区间;</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">searchlr</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree[index].l &gt;= left &amp;&amp; tree[index].r &lt;= right) <span class="comment">//此节点被要查询的区间包含</span></span><br><span class="line">    &#123;</span><br><span class="line">        ans += tree[index].sum;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tree[index &lt;&lt; <span class="number">1</span>].r &gt;= left) <span class="comment">//要查询的区间有部分在左子树</span></span><br><span class="line">        searchlr(index &lt;&lt; <span class="number">1</span>, left, right);</span><br><span class="line">    <span class="keyword">if</span> (tree[(index &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>].l &lt;= right) <span class="comment">//要查询的区间有部分在右子树</span></span><br><span class="line">        searchlr((index &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>, left, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例题1代码综上即可，总的就不放了，<del>因为太乱了</del></p><h5 id="区间修改"><a href="#区间修改" class="headerlink" title="区间修改"></a>区间修改</h5><p>然后便是例题2，这一题不同于前一题，因为涉及了区间修改，那么就要涉及另一个东西：<code>LazyTag</code></p><p><code>LazyTag</code>我感觉跟图片懒加载有点像，就是不涉及真正使用是不需要深入加载</p><p>首先，懒标记的作用是记录每次、每个节点要更新的值,优点在于传递式记录而不是全记录（全记录还是很慢）</p><p>当执行区间修改操作时：<br>若整个区间都被操作时，记录在公共祖先节点上；只修改了一部分，那么就记录在这部分的公共祖先上；如果只修改了自己的话，那就只改变自己。</p><p>之后，如果我们采用上述的优化方式的话，我们就需要在每次区间的查询修改时<code>pushdown</code>一次，以免重复或者冲突或者爆炸qwq</p><p>至于<code>pushdown</code>，就是将节点的lazytag信息向下传递</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree[index].tag) <span class="comment">//如果有信息</span></span><br><span class="line">    &#123;</span><br><span class="line">        tree[index &lt;&lt; <span class="number">1</span>].sum += tree[index].tag * (tree[index &lt;&lt; <span class="number">1</span>].r - tree[index &lt;&lt; <span class="number">1</span>].l + <span class="number">1</span>); <span class="comment">//把左子树的sum加上</span></span><br><span class="line">        tree[(index &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>].sum += tree[index].tag * (tree[(index &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>].r - tree[(index &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>].l + <span class="number">1</span>); <span class="comment">//把右子树的sum加上</span></span><br><span class="line">        tree[index &lt;&lt; <span class="number">1</span>].tag += tree[index].tag; <span class="comment">//将懒标记信息传递</span></span><br><span class="line">        tree[(index &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>].tag += tree[index].tag;</span><br><span class="line">        tree[index].tag = <span class="number">0</span>; <span class="comment">//清零本节点标记^.^</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addlr</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree[index].l &gt;= left &amp;&amp; tree[index].r &lt;= right)</span><br><span class="line">    &#123;</span><br><span class="line">        tree[index].sum += (<span class="keyword">long</span> <span class="keyword">long</span>) k * (tree[index].r - tree[index].l + <span class="number">1</span>); </span><br><span class="line">        tree[index].tag += k; <span class="comment">// lazy tag</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果区间修改的区间没有包含本区间，那就要更新一次懒标记，不然下一层算的时候会出锅</span></span><br><span class="line">    pushdown(index);</span><br><span class="line">    <span class="keyword">if</span> (tree[index &lt;&lt; <span class="number">1</span>].r &gt;= left)</span><br><span class="line">        addlr(index &lt;&lt; <span class="number">1</span>, left, right, k);</span><br><span class="line">    <span class="keyword">if</span> (tree[(index &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>].l &lt;= right)</span><br><span class="line">        addlr((index &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>, left, right, k);</span><br><span class="line"></span><br><span class="line">    tree[index].sum = tree[index &lt;&lt; <span class="number">1</span>].sum + tree[(index &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>].sum; <span class="comment">//最后回来累计上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="区间查询（有懒标记）"><a href="#区间查询（有懒标记）" class="headerlink" title="区间查询（有懒标记）"></a>区间查询（有懒标记）</h5><p>还是分块思想，每查到一个区间，有三种选择：</p><p>1、如果这个区间被完全包括在目标区间内，那么加上这个区间的和，然后return；</p><p><strong>pushdown</strong>（很重要）</p><p>2、如果这个区间的right&gt;目标区间的left，那么查询这个区间；</p><p>3、如果这个区间的left&lt;目标区间的right，也查询这个区间;</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">searchlr</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree[index].l &gt;= left &amp;&amp; tree[index].r &lt;= right)</span><br><span class="line">    &#123;</span><br><span class="line">        ans += tree[index].sum;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    spread(index);<span class="comment">//不要忘记传递信息</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tree[index &lt;&lt; <span class="number">1</span>].r &gt;= left)</span><br><span class="line">        searchlr(index &lt;&lt; <span class="number">1</span>, left, right);</span><br><span class="line">    <span class="keyword">if</span> (tree[(index &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>].l &lt;= right)</span><br><span class="line">        searchlr((index &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>, left, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就完事了！！！</p><p>那我们来做到题目吧<br><del>不，我不想做题目</del><br>四倍经验，一次满足😲<br>哦？？</p><h3 id="线段树的小题目"><a href="#线段树的小题目" class="headerlink" title="线段树的小题目"></a>线段树的小题目</h3><p><a href="https://www.luogu.com.cn/problem/P2574">Luogu P2574</a></p><h4 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h4><p>AKN 觉得第一题太水了，不屑于写第一题，所以他又玩起了新的游戏。在游戏中，他发现，这个游戏的伤害计算有一个规律，规律如下</p><p>拥有一个伤害串，是一个长度为 $n$ 的只含字符 <code>0</code> 和字符 <code>1</code> 的字符串。规定这个字符串的首字符是第一个字符，即下标从 $1$ 开始。</p><p>给定一个范围 $[l, r]$，伤害为伤害串的这个范围内中字符 <code>1</code> 的个数</p><p>会修改伤害串中的数值，修改的方法是把 $[l, r]$ 中所有原来的字符 <code>0</code> 变成 <code>1</code>，将 <code>1</code> 变成 <code>0</code>。</p><p>AKN 想知道一些时刻的伤害，请你帮助他求出这个伤害。</p><h4 id="题解！"><a href="#题解！" class="headerlink" title="题解！"></a>题解！</h4><p>首先这是一道线段树的题，那么线段树的节点都记录了什么呢？<br>首先是左右端点（废话，但是cjc巨佬告诉我可以不用l，r），然后是<code>sum</code>代表该区间<code>1</code>的数量，<code>tag</code>懒标记其实就是此区间变不变，因为翻来翻去就回来了<br>因为是01变化，所以<code>反转后1的个数</code>就等于<code>区间长度</code>-<code>原本1的个数</code><br>其他的操作和线段树差不多，要注意的是<code>pushdown</code>的思路（有点小坑）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree[index].tag)</span><br><span class="line">    &#123;</span><br><span class="line">        tree[lson].sum = (tree[lson].r - tree[lson].l + <span class="number">1</span>) - tree[lson].sum; <span class="comment">//更新左子树，左子树翻转</span></span><br><span class="line">        tree[rson].sum = (tree[rson].r - tree[rson].l + <span class="number">1</span>) - tree[rson].sum; <span class="comment">//右</span></span><br><span class="line">        tree[lson].tag ^= <span class="number">1</span>; <span class="comment">//更新左右子树信息，0变1，1变0</span></span><br><span class="line">        tree[rson].tag ^= <span class="number">1</span>;</span><br><span class="line">        tree[index].tag = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总体代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxN 200000 + 9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson index &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson index &lt;&lt; 1 | 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">    <span class="keyword">bool</span> tag = <span class="number">0</span>;</span><br><span class="line">&#125;tree[<span class="number">4</span> * MaxN];<span class="comment">//不要忘记开4倍</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, input[MaxN], ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tree[index].l = l;</span><br><span class="line">    tree[index].r = r;</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">        &#123;</span><br><span class="line">            tree[index].sum = input[l];</span><br><span class="line">            <span class="keyword">return</span> input[l];</span><br><span class="line">        &#125;</span><br><span class="line">    tree[index].sum = build(lson, l, (l + r) &gt;&gt; <span class="number">1</span>) + build(rson, ((l + r) &gt;&gt; <span class="number">1</span>) + <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">return</span> tree[index].sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree[index].tag)</span><br><span class="line">    &#123;</span><br><span class="line">        tree[lson].sum = (tree[lson].r - tree[lson].l + <span class="number">1</span>) - tree[lson].sum;</span><br><span class="line">        tree[rson].sum = (tree[rson].r - tree[rson].l + <span class="number">1</span>) - tree[rson].sum;</span><br><span class="line">        tree[lson].tag ^= <span class="number">1</span>;</span><br><span class="line">        tree[rson].tag ^= <span class="number">1</span>;</span><br><span class="line">        tree[index].tag = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree[index].l &gt;= l &amp;&amp; tree[index].r &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        tree[index].sum = (tree[index].r - tree[index].l + <span class="number">1</span>) - tree[index].sum;</span><br><span class="line">        tree[index].tag ^= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pushdown(index);</span><br><span class="line">    <span class="keyword">if</span> (tree[lson].r &gt;= l)</span><br><span class="line">        add(lson, l, r);</span><br><span class="line">    <span class="keyword">if</span> (tree[rson].l &lt;= r)</span><br><span class="line">        add(rson, l, r);</span><br><span class="line">    tree[index].sum = tree[lson].sum + tree[rson].sum;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree[index].l &gt;= l &amp;&amp; tree[index].r &lt;= r)</span><br><span class="line">        &#123;</span><br><span class="line">            ans += tree[index].sum;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    pushdown(index);</span><br><span class="line">    <span class="keyword">if</span> (tree[lson].r &gt;= l)</span><br><span class="line">        ask(lson, l, r);</span><br><span class="line">    <span class="keyword">if</span> (tree[rson].l &lt;= r)</span><br><span class="line">        ask(rson, l, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch[MaxN];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, &amp;ch);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            input[i + <span class="number">1</span>] = ch[i] ^ <span class="number">48</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//输入</span></span><br><span class="line">    build(<span class="number">1</span>, <span class="number">1</span>, n);<span class="comment">//建树</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="number">0</span>)<span class="comment">//变换</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;b, &amp;c);</span><br><span class="line">            add(<span class="number">1</span>, b, c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="number">1</span>)<span class="comment">//查询、输出</span></span><br><span class="line">        &#123;</span><br><span class="line">            ans = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;b, &amp;c);</span><br><span class="line">            ask(<span class="number">1</span>, b, c);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="四倍经验！！！"><a href="#四倍经验！！！" class="headerlink" title="四倍经验！！！"></a>四倍经验！！！</h4><p>做出这一题，剩下的这几题思路一摸一样，只用注意一下各个题目的初始条件和查询方式即可<br>然后就可以收获好多AC啦！！！</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>发现线段树理清了思路还是<del>挺好打的</del>一个数据结构，但是要注意的事情还是挺多的，毕竟比较长：<br>1.tree数组要开4倍<br>2.建议用宏定义进行一波lson rson什么的定义，不然可能会打到崩溃<br>3.暂时好像没啥了</p><p>总之，<del>你看这个代码它又长又宽，就像这个鼠标它又大又圆（大雾）</del> 希望大家都可以熟练运用线段树！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这两节课学习了 &lt;code&gt;线段树&lt;/code&gt; 这个高级的东西。。&lt;br&gt;于是乎来发一些理解和题解以便以后复习。&lt;/p&gt;
&lt;h3 id=&quot;什么是线段树&quot;&gt;&lt;a href=&quot;#什么是线段树&quot; class=&quot;headerlink&quot; title=&quot;什么是线段树&quot;&gt;&lt;/a&gt;什么是线段树&lt;/h3&gt;&lt;p&gt;先来康康这类问题：&lt;br&gt;长度为$n$的数列${a_1, a_2, … , a_n}$&lt;br&gt;（1）求最值：给定$i$,$j&amp;lt;=n$，求${a_i, …, a_j}$区间内的最值。&lt;br&gt;（2）修改元素：给定$k$和$x$，把$a_k$改成$x$。&lt;br&gt;显然你可以用&lt;del&gt;暴力&lt;/del&gt;去做，但是&lt;/p&gt;</summary>
    
    
    
    <category term="算法学习" scheme="https://hntr.xyz/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="luogu" scheme="https://hntr.xyz/tags/luogu/"/>
    
    <category term="线段树" scheme="https://hntr.xyz/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>P1441题解</title>
    <link href="https://hntr.xyz/P1441%E9%A2%98%E8%A7%A3.html"/>
    <id>https://hntr.xyz/P1441%E9%A2%98%E8%A7%A3.html</id>
    <published>2019-10-11T16:00:00.000Z</published>
    <updated>2020-01-07T11:52:18.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problem/P1441">题目链接</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>现有n个砝码，重量分别为a1，a2，a3，……，an，在去掉m个砝码后，问最多能称量出多少不同的重量（不包括0）。</p><p>请注意，砝码只能放在其中一边。</p><a id="more"></a><p>##　输入格式<br>输入文件weight.in的第1行为有两个整数n和m，用空格分隔</p><p>第2行有n个正整数a1，a2，a3，……，an，表示每个砝码的重量。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出文件weight.out仅包括1个整数，为最多能称量出的重量数量。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>3 1<br>1 2 2</p><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>3</p><h2 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h2><h3 id="【样例说明】"><a href="#【样例说明】" class="headerlink" title="【样例说明】"></a>【样例说明】</h3><p>在去掉一个重量为2的砝码后，能称量出1，2，3共3种重量。</p><h3 id="【数据规模】"><a href="#【数据规模】" class="headerlink" title="【数据规模】"></a>【数据规模】</h3><p>对于20%的数据，m=0；</p><p>对于50%的数据，m≤1；</p><p>对于50%的数据，n≤10；</p><p>对于100%的数据，n≤20，m≤4，m＜n，ai≤100。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先枚举取哪几个，然后DP找这种的取法的最多可称量数，与<code>ans</code>比较即可</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>, n, m, a[<span class="number">25</span>], arr[<span class="number">25</span>];</span><br><span class="line"><span class="keyword">bool</span> took[<span class="number">25</span>],dp[<span class="number">100</span>*<span class="number">100</span>+<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(arr, <span class="number">0</span>, <span class="keyword">sizeof</span>(arr));</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>,sum=<span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        <span class="keyword">if</span> (!took[i])</span><br><span class="line">        &#123;</span><br><span class="line">            arr[++cnt]=a[i];</span><br><span class="line">            sum += a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; sum;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=cnt; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=sum; j&gt;=arr[i]; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[j]|=dp[j-arr[i]];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> tmp=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=sum; i++)</span><br><span class="line">        tmp+=dp[i];</span><br><span class="line"></span><br><span class="line">    ans=max(ans,tmp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cnt, <span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cnt == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        check();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=index; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        took[i]=<span class="number">1</span>;</span><br><span class="line">        dfs(cnt<span class="number">-1</span>, i+<span class="number">1</span>);</span><br><span class="line">        took[i]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line"></span><br><span class="line">    dfs(m, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.luogu.org/problem/P1441&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;现有n个砝码，重量分别为a1，a2，a3，……，an，在去掉m个砝码后，问最多能称量出多少不同的重量（不包括0）。&lt;/p&gt;
&lt;p&gt;请注意，砝码只能放在其中一边。&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="https://hntr.xyz/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="动态规划" scheme="https://hntr.xyz/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="luogu" scheme="https://hntr.xyz/tags/luogu/"/>
    
    <category term="搜索" scheme="https://hntr.xyz/tags/%E6%90%9C%E7%B4%A2/"/>
    
    <category term="BFS" scheme="https://hntr.xyz/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>POJ-2349题解</title>
    <link href="https://hntr.xyz/POJ-2349%E9%A2%98%E8%A7%A3.html"/>
    <id>https://hntr.xyz/POJ-2349%E9%A2%98%E8%A7%A3.html</id>
    <published>2019-08-20T13:04:59.000Z</published>
    <updated>2020-01-07T11:52:18.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://poj.org/problem?id=2349">POJ-2349</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>The Department of National Defence (DND) wishes to connect several northern outposts by a wireless network. Two different communication technologies are to be used in establishing the network: every outpost will have a radio transceiver and some outposts will in addition have a satellite channel. </p><a id="more"></a><p>Any two outposts with a satellite channel can communicate via the satellite, regardless of their location. Otherwise, two outposts can communicate by radio only if the distance between them does not exceed D, which depends of the power of the transceivers. Higher power yields higher D but costs more. Due to purchasing and maintenance considerations, the transceivers at the outposts must be identical; that is, the value of D is the same for every pair of outposts. </p><p>Your job is to determine the minimum D required for the transceivers. There must be at least one communication path (direct or indirect) between every pair of outposts.</p><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>The first line of input contains N, the number of test cases. The first line of each test case contains 1 &lt;= S &lt;= 100, the number of satellite channels, and S &lt; P &lt;= 500, the number of outposts. P lines follow, giving the (x,y) coordinates of each outpost in km (coordinates are integers between 0 and 10,000).</p><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>For each case, output should consist of a single line giving the minimum D required to connect the network. Output should be specified to 2 decimal points.</p><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2 4</span><br><span class="line">0 100</span><br><span class="line">0 300</span><br><span class="line">0 600</span><br><span class="line">150 750</span><br></pre></td></tr></table></figure><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">212.13</span><br></pre></td></tr></table></figure><p>看不懂题目的话就<a href="https://translate.google.cn/">翻译</a>吧</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>使用prim构造最小生成树<br>prim是什么 具体请google或者百度搜一搜 但是经历了模拟考用prim构建最小生成树的悲惨过程<br>建议去还是学一下Kruskal算法</p><blockquote><p>推荐博客地址<a href="https://blog.csdn.net/a2392008643/article/details/81781766">这篇文章</a></p></blockquote><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXINT 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">&#125;l[<span class="number">600</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m,n;</span><br><span class="line"><span class="keyword">double</span> dis[<span class="number">600</span>],d[<span class="number">605</span>][<span class="number">605</span>];</span><br><span class="line"><span class="keyword">bool</span> book[<span class="number">600</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        dis[i]=d[<span class="number">1</span>][i];</span><br><span class="line">    book[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> k=<span class="number">0</span>,mm=MAXINT;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="keyword">if</span> (dis[j]&lt;mm &amp;&amp; book[j]==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            mm=dis[j];</span><br><span class="line">            k=j;</span><br><span class="line">        &#125;</span><br><span class="line">        book[k]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="keyword">if</span> (dis[j]&gt;d[j][k] &amp;&amp; book[j]==<span class="number">0</span>)</span><br><span class="line">                dis[j]=d[j][k];</span><br><span class="line">    &#125;</span><br><span class="line">    sort(dis+<span class="number">1</span>,dis+n+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//for (int i=1;i&lt;=n;i++)</span></span><br><span class="line">    <span class="comment">//    cout&lt;&lt;dis[i]&lt;&lt;&quot; &quot;;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.2f\n&quot;</span>,dis[n-m+<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">    <span class="keyword">while</span> (x&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(book,<span class="number">0</span>,<span class="keyword">sizeof</span>(book));</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;m&gt;&gt;n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;l[i].x&gt;&gt;l[i].y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i==j)</span><br><span class="line">                        d[i][j]=<span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        d[i][j]=<span class="built_in">sqrt</span>((l[i].x-l[j].x)*(l[i].x-l[j].x)+(l[i].y-l[j].y)*(l[i].y-l[j].y));</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        for (int i=1;i&lt;=n;i++)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            for (int j=1;j&lt;=n;j++)</span></span><br><span class="line"><span class="comment">            cout&lt;&lt;d[i][j]&lt;&lt;&quot;  &quot;;</span></span><br><span class="line"><span class="comment">            cout&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        print();</span><br><span class="line">        x--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个用的还是prim 因为打起来跟djikstra很像 而去对于这题比较方便</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;http://poj.org/problem?id=2349&quot;&gt;POJ-2349&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;The Department of National Defence (DND) wishes to connect several northern outposts by a wireless network. Two different communication technologies are to be used in establishing the network: every outpost will have a radio transceiver and some outposts will in addition have a satellite channel. &lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="https://hntr.xyz/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="POJ" scheme="https://hntr.xyz/tags/POJ/"/>
    
    <category term="最小生成树" scheme="https://hntr.xyz/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    
    <category term="Prim" scheme="https://hntr.xyz/tags/Prim/"/>
    
  </entry>
  
  <entry>
    <title>HDU-1312题解</title>
    <link href="https://hntr.xyz/HDU-1312%E9%A2%98%E8%A7%A3.html"/>
    <id>https://hntr.xyz/HDU-1312%E9%A2%98%E8%A7%A3.html</id>
    <published>2019-08-20T12:53:18.000Z</published>
    <updated>2020-01-07T11:52:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>据说<a href="https://translate.google.cn/">翻译</a>是个好东西（这句与题目无关😃）</p><p>There is a rectangular room, covered with square tiles. Each tile is colored either red or black. A man is standing on a black tile. From a tile, he can move to one of four adjacent tiles. But he can’t move on red tiles, he can move only on black tiles. </p><a id="more"></a><p>Write a program to count the number of black tiles which he can reach by repeating the moves described above. </p><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>The input consists of multiple data sets. A data set starts with a line containing two positive integers W and H; W and H are the numbers of tiles in the x- and y- directions, respectively. W and H are not more than 20. </p><p>There are H more lines in the data set, each of which includes W characters. Each character represents the color of a tile as follows. </p><p>‘.’ - a black tile<br>‘#’ - a red tile<br>‘@’ - a man on a black tile(appears exactly once in a data set) </p><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>For each data set, your program should output a line which contains the number of tiles he can reach from the initial tile (including itself). </p><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">6 9</span><br><span class="line">....#.</span><br><span class="line">.....#</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">#@...#</span><br><span class="line">.#..#.</span><br><span class="line">11 9</span><br><span class="line">.#.........</span><br><span class="line">.#.#######.</span><br><span class="line">.#.#.....#.</span><br><span class="line">.#.#.###.#.</span><br><span class="line">.#.#..@#.#.</span><br><span class="line">.#.#####.#.</span><br><span class="line">.#.......#.</span><br><span class="line">.#########.</span><br><span class="line">...........</span><br><span class="line">11 6</span><br><span class="line">..#..#..#..</span><br><span class="line">..#..#..#..</span><br><span class="line">..#..#..###</span><br><span class="line">..#..#..#@.</span><br><span class="line">..#..#..#..</span><br><span class="line">..#..#..#..</span><br><span class="line">7 7</span><br><span class="line">..#.#..</span><br><span class="line">..#.#..</span><br><span class="line">###.###</span><br><span class="line">...@...</span><br><span class="line">###.###</span><br><span class="line">..#.#..</span><br><span class="line">..#.#..</span><br><span class="line">0 0</span><br></pre></td></tr></table></figure><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">45</span><br><span class="line">59</span><br><span class="line">6</span><br><span class="line">13</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>一道深搜水题 <del>嗯我就是来水题解的</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">char</span> <span class="built_in">map</span>[<span class="number">22</span>][<span class="number">22</span>];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">map</span>[a][b] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    result++;</span><br><span class="line">    <span class="keyword">if</span> (a - <span class="number">1</span> &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">map</span>[a - <span class="number">1</span>][b] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">        dfs(a - <span class="number">1</span>, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a + <span class="number">1</span> &lt;= n &amp;&amp; <span class="built_in">map</span>[a + <span class="number">1</span>][b] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">        dfs(a + <span class="number">1</span>, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (b - <span class="number">1</span> &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">map</span>[a][b - <span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">        dfs(a, b - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (b + <span class="number">1</span> &lt;= m &amp;&amp; <span class="built_in">map</span>[a][b + <span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">        dfs(a, b + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span> &amp;&amp; m == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">                <span class="keyword">char</span> s;</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">                <span class="keyword">if</span> (s == <span class="string">&#x27;@&#x27;</span>) &#123;</span><br><span class="line">                    x = i; y = j;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">map</span>[i][j] = s;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">map</span>[x][y] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (x<span class="number">-1</span> &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">map</span>[x - <span class="number">1</span>][y] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">            dfs(x - <span class="number">1</span>, y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x + <span class="number">1</span> &lt;= n &amp;&amp; <span class="built_in">map</span>[x + <span class="number">1</span>][y] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">            dfs(x + <span class="number">1</span>, y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (y - <span class="number">1</span> &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">map</span>[x][y - <span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">            dfs(x, y - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (y + <span class="number">1</span> &lt;= m &amp;&amp; <span class="built_in">map</span>[x][y + <span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">            dfs(x, y + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; result &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        result = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;据说&lt;a href=&quot;https://translate.google.cn/&quot;&gt;翻译&lt;/a&gt;是个好东西（这句与题目无关😃）&lt;/p&gt;
&lt;p&gt;There is a rectangular room, covered with square tiles. Each tile is colored either red or black. A man is standing on a black tile. From a tile, he can move to one of four adjacent tiles. But he can’t move on red tiles, he can move only on black tiles. &lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="https://hntr.xyz/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="HDU" scheme="https://hntr.xyz/tags/HDU/"/>
    
    <category term="搜索" scheme="https://hntr.xyz/tags/%E6%90%9C%E7%B4%A2/"/>
    
    <category term="DFS" scheme="https://hntr.xyz/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>POJ-3784题解</title>
    <link href="https://hntr.xyz/POJ-3784%E9%A2%98%E8%A7%A3.html"/>
    <id>https://hntr.xyz/POJ-3784%E9%A2%98%E8%A7%A3.html</id>
    <published>2019-08-20T12:41:45.000Z</published>
    <updated>2020-01-07T11:52:18.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://poj.org/problem?id=3784">POJ-3784</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>For this problem, you will write a program that reads in a sequence of 32-bit signed integers. After each odd-indexed value is read, output the median (middle value) of the elements received so far.</p><a id="more"></a><p>##Input</p><p>The first line of input contains a single integer P, (1 ≤ P ≤ 1000), which is the number of data sets that follow. The first line of each data set contains the data set number, followed by a space, followed by an odd decimal integer M, (1 ≤ M ≤ 9999), giving the total number of signed integers to be processed. The remaining line(s) in the dataset consists of the values, 10 per line, separated by a single space. The last line in the dataset may contain less than 10 values.</p><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>For each data set the first line of output contains the data set number, a single space and the number of medians output (which should be one-half the number of input values plus one). The output medians will be on the following lines, 10 per line separated by a single space. The last line may have less than 10 elements, but at least 1 element. There should be no blank lines in the output.</p><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">3 </span><br><span class="line">1 9 </span><br><span class="line">1 2 3 4 5 6 7 8 9 </span><br><span class="line">2 9 </span><br><span class="line">9 8 7 6 5 4 3 2 1 </span><br><span class="line">3 23 </span><br><span class="line">23 41 13 22 -3 24 -31 -11 -8 -7 </span><br><span class="line">3 5 103 211 -311 -45 -67 -73 -81 -99 </span><br><span class="line">-33 24 56</span><br></pre></td></tr></table></figure><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1 5</span><br><span class="line">1 2 3 4 5</span><br><span class="line">2 5</span><br><span class="line">9 8 7 6 5</span><br><span class="line">3 12</span><br><span class="line">23 23 22 22 13 3 5 5 3 -3 </span><br><span class="line">-7 -3</span><br></pre></td></tr></table></figure><p>如果你题目看不懂的话，快试一试<a href="https://translate.google.cn/">翻译</a></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>我们使用维护两个堆 一个大根堆一个小根堆的方法来进行动态中位数查找<br>当然我推荐直接使用<code>STL</code>的<code>priority_queue</code>，因为不容易写错^ ^<br>具体的维护过程如下：</p><p>我们现在读入了一个新的数$x$<br>　　1、如果他比大根堆的堆顶要小，也就是说明他比当前中位数要小，那么把$x$插入大根堆<br>　　2、如果他比大根堆的堆顶要大，也就是说明他比当前中位数要打，那么把$x$插入小根堆<br>　　3、在维护的过程中如果发现大根堆比小根堆少，弹出小根堆的堆顶插入大根堆直至符合要求<br>　　4、在维护的过程中如果发现大根堆的$size-$小根堆的$size&gt;1$ ，弹出大根堆的堆顶假如小根堆直至符合要求</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">priority_queue</span> &lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt; &gt; q1;<span class="comment">//这个是小根堆 分不清的时候可以跑个程序试一试</span></span><br><span class="line"><span class="built_in">priority_queue</span> &lt;<span class="keyword">int</span>&gt; q2;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span> &gt; a;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (q1.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        q1.push(x);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x&gt;q1.top())</span><br><span class="line">        q1.push(x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        q2.push(x);</span><br><span class="line">    <span class="keyword">while</span> (q2.size() &gt; q1.size())</span><br><span class="line">    &#123;</span><br><span class="line">        q1.push(q2.top());</span><br><span class="line">        q2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (q1.size() &gt; q2.size() + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        q2.push(q1.top());</span><br><span class="line">        q1.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t,k;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (q1.size()) q1.pop();</span><br><span class="line">        <span class="keyword">while</span> (q2.size()) q2.pop();</span><br><span class="line">        a.clear();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>  m,n;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;m&gt;&gt;n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;k;</span><br><span class="line">            Add(k);</span><br><span class="line">            <span class="keyword">if</span> (i%<span class="number">2</span>!=<span class="number">0</span>) a.push_back(q1.top());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;m&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;(n+<span class="number">1</span>)/<span class="number">2</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; i % <span class="number">10</span> == <span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">10</span>) <span class="built_in">putchar</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;http://poj.org/problem?id=3784&quot;&gt;POJ-3784&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;For this problem, you will write a program that reads in a sequence of 32-bit signed integers. After each odd-indexed value is read, output the median (middle value) of the elements received so far.&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="https://hntr.xyz/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="POJ" scheme="https://hntr.xyz/tags/POJ/"/>
    
    <category term="堆" scheme="https://hntr.xyz/tags/%E5%A0%86/"/>
    
  </entry>
  
</feed>
